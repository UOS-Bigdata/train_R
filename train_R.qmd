---
title: "스포츠과학원 재직자교육 - R을 활용한 데이터 분석"
author: "서울시립대학교 빅데이터 혁신융합대학 사업단"
date: "today"

format:
  html:
    toc: true
    embed-resources: true
    fig-cap-location: top
  docx: 
    toc: true
    toc-depth: 2 
    number-sections: true
    reference-doc: custom-reference-doc-landscape.docx
---

## 패키지 로드 및 데이터 불러오기

### 패키지 불러오기 (`library()`)

앞서 `install.packages()`를 통해 패키지를 설치한 것은 스마트폰에 앱을 '다운로드'한 것과 같다. 앱을 사용하려면 아이콘을 눌러서 실행해야 하듯이, R에서도 설치된 패키지를 사용하려면 이 패키지를 사용 할 것이라 선언해 주는 과정이 필요하다.

이때 사용하는 함수가 `library()`이다,

- **설치:** 컴퓨터에 한 번만 하면 됨. (인터넷 필요)

- **실행:** RStudio를 켤 때마다, 해당 기능을 쓰기 위해 매번 실행해야 함. (오프라인 가능)

```{r}
#| eval: FALSE
#| message: FALSE
#| warning: FALSE

# 데이터를 다루는 'dplyr' 패키지 실행
library(dplyr)
# 엑셀 파일을 읽어오는 'readxl' 패키지 실행
library(readxl)
# 그래프를 그리는 'ggplot2' 패키지 실행
library(ggplot2)
```

현재 내 RStudio에 어떤 패키지들이 로드되어(활성화되어) 있는지 확인하려면 `search()` 함수를 사용한다.

```{r}
#| message: FALSE
search()
```

::: {.callout-note}
### 주의사항
R의 패키지들은 전 세계 사용자들이 자발적으로 만든 것이므로 아주 드물게 오류가 있을 수 있다는 점을 항상 염두에 두어야 한다.
:::

### 외부 데이터 불러오기

R에서 데이터를 직접 타이핑해서 입력하는 경우는 거의 없다. 대부분 엑셀이나 회사 시스템에서 내려받은 파일을 R로 가져와서 분석하게 된다. 가장 많이 사용하는 두 가지 파일 형식인 `.csv`와 `.xlsx(엑셀)` 파일을 불러오는 방법을 알아보자.

1.  **CSV 파일 불러오기**

    가장 흔하게 접하게 될 파일 형식은 `.csv`이이다. CSV는 **Comma Separated Values**의 약자로, 겉보기엔 엑셀 파일 같지만 실제로는 데이터들이 쉼표(,)로 구분된 단순한 텍스트 파일이이다. 용량이 가볍고 호환성이 좋아 데이터 분석에서 가장 선호하는 형식이다.

    R에서 CSV 파일을 불러올 때는 `read.csv()` 함수를 사용한다.

::: {.callout-note}
### 파일 경로 지정 팁

윈도우 탐색기에서 파일 경로를 복사하면 `C:\Users\Data` 처럼 역슬래시(`\`)로 되어 있다. R에서는 이를 인식하지 못하므로, 반드시 슬래시(`/`) 두 개(`\\`)로 바꿔주어야 한다.

-   \(X\) `"C:\Users\Data\file.csv"`
-   \(O\) `"C:/Users/Data/file.csv`
:::

```{r}
#| eval: FALSE
# 파일 경로를 큰따옴표("") 안에 넣어주세요.
read.csv("C:/Users/Data/my_data.csv")
```

2.  **한글이 깨져서 보일 때 (인코딩 문제)**

    한국인 사용자에게 가장 골치 아픈 문제이다. 파일을 불러왔는데 `ꍪꍫ` 같은 외계어가 나온다면 **인코딩(Encoding)** 방식이 맞지 않아서이다. 이럴 때는 `fileEncoding` 옵션을 추가한다.

    -   **CP949**: 보통 윈도우 환경에서 만든 파일일 때

    -   **UTF-8**: 맥(Mac)이나 웹, 최신 시스템에서 만든 파일일 때

```{r}
#| eval: FALSE
# 윈도우 엑셀로 저장한 CSV라면 보통 CP949입니다.
read.csv("파일경로/파일명.csv", fileEncoding = "CP949")

# 그래도 깨진다면 UTF-8을 시도해보세요.
read.csv("파일경로/파일명.csv", fileEncoding = "UTF-8")
```

3.  **첫 번째 줄이 제목일 때 (Header)**

    데이터 파일의 첫 번째 줄(행)이 변수명(칼럼명)인 경우가 많다. `read.csv`는 기본적으로 첫 줄을 제목으로 인식하지만(`header = TRUE`), 만약 첫 줄부터 바로 데이터가 시작된다면 `header = FALSE` 옵션을 주어야 한다.

4.  **엑셀 파일(.xlsx) 불러오기**

    순수 엑셀 파일(`.xls`, `.xlsx`)을 불러올 때는 R의 기본 기능으로는 안 되고, `readxl`이라는 패키지의 힘을 빌려야 한다. (위에서 `library(readxl)`을 했는지 꼭 확인!)

    -   `.xls` 파일 (구버전 엑셀): `read_xls()` 함수 사용

    -   `.xlsx` 파일 (신버전 엑셀): `read_xlsx()` 함수 사용

    엑셀 파일은 여러 개의 시트(Sheet) 로 구성된 경우가 많다. 특정 시트의 데이터만 가져오고 싶다면 `sheet` 옵션에 번호나 시트 이름을 적어주면 된다.

```{r}
#| eval: FALSE

# 엑셀 파일 불러오기
read_xlsx("C:/Users/Data/sales_data.xlsx")

# 두 번째 시트에 있는 데이터만 가져오고 싶을 때
read_xlsx("C:/Users/Data/sales_data.xlsx", sheet = 2)
```

# 1. R의 기초

## 1.1 연산

### 1.1.1 기초 연산

`R`은 사칙연산(덧셈, 뺄셈, 곱셈, 나눗셈)에 대한 기본적인 기능을 제공한다.\
특히 곱셈 기호는 문자 `x`가 아니라 연산자 `*`를 사용한다는 점에 주의하자.

```{r}
#| eval: FALSE
1 + 2
```

```{r}
#| eval: FALSE
1 - 2
```

```{r}
#| eval: FALSE
2 * 2
```

```{r}
#| eval: FALSE
2 / 2
```

### 1.1.2 비교 연산

`R`에서는 부등호와 등호를 이용한 **비교 연산**이 가능하다.\
비교 연산자는 조건문, 필터링, 논리 판단 등에 자주 사용된다.

비교 연산을 수행하면 결과로 `TRUE` 또는 `FALSE`가 출력된다.

```{r}
#| eval: FALSE
3 > 2      # TRUE
5 == 10    # FALSE
4 != 4     # FALSE
7 <= 9     # TRUE
```

## 1.2 변수

### 1.2.1 변수 할당

`R`에서 변수를 생성(할당)하는 방법은 여러 가지가 있지만, 그 중 `<-` 또는 `=` 연산자가 가장 자주 사용된다.\
`x`라는 변수에 2를, `y`라는 변수에 5를 저장해보자:

```{r}
#| eval: FALSE
x <- 2
y = 5
```

### 1.2.2 변수 이름 규칙

`R`에서 변수 이름을 정할 때는 다음과 같은 규칙이 적용된다:

1.  변수 이름은 반드시 **영문자 또는 마침표(`.`), 밑줄(`_`)로 시작**해야 한다. 숫자로 시작할 수는 없다.
2.  변수 이름에는 **영문자, 숫자, 마침표(`.`), 밑줄(`_`)**만 사용할 수 있다.
3.  **공백(띄어쓰기)**이나 특수문자(예: `@`, `!`, `-` 등)는 사용할 수 없다.
4.  대소문자를 구분한다. (`score`와 `Score`는 다른 변수로 인식됨)
5.  `R`의 **예약어**(예: `if`, `for`, `TRUE`, `function` 등)는 변수 이름으로 사용할 수 없다.

### 1.2.3 변수 제거

변수를 제거하려면 `rm()` 함수를 사용한다.\
삭제하고자 하는 변수명을 `rm()` 함수 안에 넣어주면 해당 변수가 메모리에서 제거된다.

-   `ls()`: 현재 작업 환경에 저장되어 있는 변수들의 이름을 나열해준다.
-   `rm()`: 변수를 삭제한다. 삭제하려는 변수의 이름을 `rm()` 함수 안에 넣어 실행하면 된다. 예: `rm(x)`는 변수 `x`를 삭제한다.

```{r}
#| eval: FALSE
x <- 10
ls()
rm(x)   # 변수 x 제거
```

## 1.3 데이터타입

`R`에서 사용되는 데이터 타입은 매우 다양하지만, 그중에서도 네 가지 주요 데이터 타입이 자주 사용된다:\
`numeric`, `character`, `logical`, `Date/POSIXct`

이번 교육에서는 이 중에서 `numeric`, `character`, `logical` 세 가지 타입을 중심으로 다루도록 하겠다.

## 1.3.1 `numeric` 자료

`R`은 대다수의 자료가 숫자형태로 존재하게 된다. `numeric` 자료는 정수, 실수를 다루며 어떤 변수가 `numeric`인지 확인하는 함수는 `is.numeric()`을 통해 이루어진다.

`R`에서는 대부분의 데이터가 숫자 형태로 표현되며, 이러한 데이터를 `numeric` 타입이라고 한다.\
`numeric` 자료형은 **정수(integer)**와 **실수(double)**를 모두 포함한다.

어떤 변수가 `numeric` 타입인지 확인하려면 `is.numeric()` 함수를 사용한다.

```{r}
#| eval: FALSE
x <- 3.14
is.numeric(x)   # TRUE
```

정수를 생성하고 싶은 경우, 숫자 뒤에 `L`을 붙이면 해당 변수를 **정수(integer)**로 생성할 수 있다.

```{r}
#| eval: FALSE
x <- 10L
is.integer(x)   # TRUE
is.numeric(x)   # TRUE (정수도 numeric의 하위 개념)
```

어떤 변수의 데이터타입을 알고 싶은 경우 `class()` 함수를 통하면 알 수 있다.

```{r}
#| eval: FALSE
x <- 3.14
class(x)    # "numeric"
```

## 1.3.2 `character` 자료

`R`에서 `character`(문자형)는 `numeric`만큼이나 자주 사용되는 데이터 타입이다.\
문자형 데이터는 텍스트, 범주형 값, 이름 등의 정보를 저장할 때 사용된다.

`R`에서는 문자형 데이터를 다루는 방식이 두 가지로 구분된다:\
하나는 일반적인 문자열 자료인 `character` 타입이고, 다른 하나는 범주형 데이터를 위한 `factor` 타입이다.

-   `character`: 단순한 문자열 데이터 (예: 이름, 도시명 등)
-   `factor`: 고정된 수준(level)을 갖는 범주형 데이터 (예: 성별, 지역구분 등)

```{r}
#| eval: FALSE
name <- "Alice"
class(name)       # "character"

gender <- factor("female", levels = c("male", "female"))
class(gender)     # "factor"
```

## 1.3.3 `logical` 자료

`R`에서 `logical`(논리형)은 참(`TRUE`) 또는 거짓(`FALSE`)의 값을 표현하는 데이터 타입이다.
조건문, 필터링, 비교 연산의 결과 등에서 매우 자주 사용된다.

논리형 데이터는 다음과 같이 직접 생성할 수 있다:

```{r}
#| eval: FALSE
a <- TRUE
b <- FALSE

class(a)   # "logical"
```

또한, 비교 연산 결과는 항상 `logical` 값을 반환한다:

```{r}
#| eval: FALSE
x <- 5
x > 3      # TRUE
x == 10    # FALSE
```

`logical` 값은 숫자 연산과도 호환되며, `TRUE`는 1, `FALSE`는 0으로 간주되어 계산에 활용될 수 있다:

```{r}
#| eval: FALSE
TRUE + TRUE    # 2
TRUE * 5 # 5
```

### 1.4 벡터 (Vector)

`R`에서 가장 기본적인 데이터 구조는 **벡터**이다.\
벡터는 **동일한 데이터 타입을 갖는 값들의 모음**으로, 숫자형, 문자형, 논리형 등 다양한 타입의 벡터를 생성할 수 있다.

벡터를 만드는 가장 일반적인 방법은 `c()` 함수를 사용하는 것이다.\
`c()`는 "combine"의 약자로 여러 값을 하나의 벡터로 결합해준다.

```{r}
#| eval: FALSE
# 숫자형 벡터
num_vec <- c(1, 2, 3, 4, 5)

# 문자형 벡터
char_vec <- c("apple", "banana", "cherry")

# 논리형 벡터
log_vec <- c(TRUE, FALSE, TRUE, TRUE)
```

벡터는 **동일한 데이터 타입**만 저장할 수 있는 자료구조이다.\
서로 다른 타입의 값을 함께 넣으면 `R`은 자동으로 **가장 일반적인 타입**으로 변환(coercion)하여 벡터를 생성한다.

예를 들어, 다음과 같은 벡터에는 세 가지 타입(숫자형, 문자형, 논리형)이 혼합되어 있으므로 문자형을 반환한다.

```{r}
#| eval: FALSE
v <- c(1, 2, "김", TRUE)
print(v)
# 출력: "1" "2" "김" "TRUE"
class(v)    # "character"
```

### 1.4.1 벡터 연산

`R`에서는 벡터 간의 연산이 **원소별(element-wise)**로 자동 수행된다.\
벡터 연산은 `R`의 강력한 기능 중 하나로, 복잡한 반복문 없이도 간결하게 계산을 처리할 수 있다.

```{r}
#| eval: FALSE
a <- c(1, 2, 3)
b <- c(4, 5, 6)

a + b   # 각 위치의 값끼리 더함: 1+4, 2+5, 3+6 → 5 7 9
a - b   # -3 -3 -3
a * b   # 4 10 18
a / b   # 0.25 0.4 0.5
```

벡터는 스칼라 값과도 연산이 가능하며, 각 원소에 동일한 연산이 적용된다:

```{r}
#| eval: FALSE
a <- c(1, 2, 3)
a + 10     # 11 12 13
a * 2      # 2 4 6
```

두 벡터의 길이가 다르면, 짧은 쪽 벡터의 값을 자동으로 반복하여 연산한다. 이를 **재활용 규칙(recycling rule)**이라고 한다.

```{r}
#| eval: FALSE
a <- c(1, 2, 3, 4)
b <- c(10, 100)

a + b     # 1+10, 2+100, 3+10, 4+100 → 11 102 13 104
```

### 1.4.2 벡터 인덱싱

`R`에서 벡터의 특정 요소에 접근하거나 일부 값을 선택하기 위해 **인덱싱**을 사용할 수 있다.\
`R`의 인덱스는 **1부터 시작**한다는 점에 주의해야 한다.

```{r}
#| eval: FALSE
x <- c(10, 20, 30, 40, 50)

x[1]       # 첫 번째 요소 10
x[3]       # 세 번째 요소 30
x[c(2, 4)] # 두 번째와 네 번째 요소 20 4
```

음수를 사용하면 해당 위치의 요소를 제외할 수 있다.

```{r}
#| eval: FALSE
x[-1]      # 첫 번째 요소 제외 20 30 40 50
x[-c(2, 5)]# 2번째와 5번째 제외 10 30 40
```

`TRUE`/`FALSE` 값을 이용해 원하는 요소만 선택할 수 있다.

```{r}
#| eval: FALSE
x <- c(5, 10, 15, 20)

x > 10          # FALSE FALSE TRUE TRUE
x[x > 10]       # 조건을 만족하는 값만 → 15 20
```

벡터에 `이름(names)` 을 지정하면, 이름을 통해 인덱싱할 수 있다.

```{r}
#| eval: FALSE
x <- c(a = 100, b = 200, c = 300)
x["b"]         # 200
names(x)       # "a" "b" "c"
```

### 1.4.3 범주형 벡터 (`factor` vector)

`R`에서는 **범주형(categorical)** 데이터를 표현할 때 `factor` 벡터를 사용한다.\
`factor`는 문자형 데이터처럼 보이지만, 내부적으로는 **고정된 수준(level)**을 가지는 **정수형 벡터**로 처리된다.

```{r}
#| eval: FALSE
gender <- c("male", "female", "male", "female", "female")
gender <- as.factor(gender)
gender
# 출력: [1] male   female male   female female
# Levels: female male
```

```{r}
#| eval: FALSE
as.numeric(gender)
```

### 1.4.4 벡터 관련 주요함수

`R`에서는 벡터를 다루기 위해 다양한 기본 함수들이 제공된다.\
아래는 자주 사용되는 대표적인 벡터 함수들이다.

`length()` — 벡터의 길이(요소 개수) 반환

```{r}
#| eval: FALSE
x <- c(10, 20, 30, 40)
length(x)   # 4
```

`sum()` — 모든 요소의 합계 계산

```{r}
#| eval: FALSE
sum(x)      # 100
```

`mean()` — 평균값 계산

```{r}
#| eval: FALSE
mean(x)     # 25
```

`max()` / `min()` — 최대값 / 최소값

```{r}
#| eval: FALSE
max(x)      # 40
min(x)      # 10
```

`sort()` - 정렬

```{r}
#| eval: FALSE
sort(x)           # 오름차순 10 20 30 40
sort(x, decreasing = TRUE)  # 내림차순 40 30 20 10
```

### 1.4.5 NA vs NULL

`R`에서 결측값(빠진 데이터)을 표현할 때는 주로 `NA`와 `NULL`이 사용된다.\
이 둘은 비슷해 보이지만 의미와 동작이 **완전히 다르다**.

`NA` (Not Available)

-   **결측값(missing value)**을 의미
-   벡터나 데이터프레임 내에서 **값은 존재하지만 비어 있음**
-   수치 연산 또는 통계 처리 대상에 포함됨

```{r}
#| eval: FALSE
x <- c(1, 2, NA, 4)
mean(x)                # NA (결측이 포함되면 결과도 NA)
mean(x, na.rm = TRUE)  # 2.33 (결측값 무시하고 계산)
```

`NULL`

-   존재 자체가 없음
-   길이가 0이고, 연산 대상에도 포함되지 않음

```{r}
#| eval: FALSE
y <- NULL
length(y)     # 0

z <- c(1, NULL, 3)   # NULL은 무시됨 c(1, 3)
```

# 2. 데이터 프레임 I

`data.frame`은 `R`에서 가장 많이 사용되는 데이터 구조 중 하나로, **여러 개의 벡터(열)를 같은 길이로 묶어 2차원 형태의 표 형식 데이터**로 만든 것이다.

엑셀의 시트처럼 **행(row)**과 **열(column)**로 구성되어 있으며,
각 열은 서로 다른 타입(`numeric`, `character`, `logical` 등)을 가질 수 있다.


아래 그림을 보자. 데이터프레임에서 **열(column)**은 각각 하나의 **변수(variable)**를 나타내고, **행(row)**은 각 변수에 대한 하나의 **관측치(observation)**를 의미한다.

::: {#fig-data1}

![](./images/tidy.png){width=80%}

데이터프레임의 구조
:::

R의 문법을 익히는 가장 효과적인 방법은 실제 데이터를 직접 다뤄보는 것이다. 이번 교육 과정에서는 `ggplot2` 패키지에 내장된 `mpg` 데이터 를 활용하여 실습을 진행한다.

::: {.callout-note}
### `mpg` 데이터 설명
`mpg` 데이터는 미국 환경 보호국(US EPA)에서 공개한 자료로, 1999년부터 2008년까지 출시된 자동차 234종의 연비 정보를 담고 있다. 일반적인 엑셀 표와 같이 행(Row)과 열(Column)로 구성된 데이터프레임 형태이다. 별도로 파일을 다운로드할 필요 없이 `ggplot2` 패키지만 로드하면 즉시 사용할 수 있어 연습용 데이터로 널리 사용된다.
:::


```{r}
library(ggplot2)
```

`mpg` 데이터의 각 열(Column)이 의미하는 바는 다음과 같다.


|  |  |  |
|------------------------|------------------------|------------------------|
| 변수명 | 설명 | 예시 |
| **manufacturer** | 제조사 | audi, hyundai, jeep 등 |
| **model** | 모델명 | a4, sonata 등 |
| **displ** | 배기량 (엔진 크기) | 숫자가 클수록 배기량이 큼 (예: 1.8, 2.0) |
| **year** | 생산연도 | 1999, 2008 |
| **cyl** | 실린더 개수 (기통) | 4기통, 6기통 등 |
| **trans** | 변속기 종류 | auto(자동), manual(수동) |
| **drv** | 구동 방식 | f(전륜), r(후륜), 4(4륜) |
| **cty** | **도심 연비** (City MPG) | 도심 주행 시 연비 (단위: 마일/갤런) |
| **hwy** | **고속도로 연비** (Highway MPG) | 고속도로 주행 시 연비 (단위: 마일/갤런) |
| **fl** | 연료 종류 | p(프리미엄), r(레귤러), e(에탄올) 등 |
| **class** | 자동차 종류 | compact(소형), suv, minivan 등 |

## 2.1 데이터 프레임의 생성

`R`에서 데이터프레임을 생성하는 방법은 여러 가지가 있지만,\
그 중 가장 간단한 방법은 `data.frame()` 함수를 사용하는 것이다.

이제 세 개의 벡터 `x`, `y`, `q`를 만들어 데이터프레임으로 결합해보자:

```{r}
#| eval: FALSE
x <- 10:1
y <- -4:5
q <- c("Hockey", "Football", "Baseball", "Curling", "Rugby", 
       "Lacrosse", "Basketball", "Tennis", "Cricket", "Soccer")

df <- data.frame(x, y, q)
```

데이터프레임의 각 열(column)에 이름을 붙이고 싶을 경우,\
`data.frame()` 함수에서 **이름 = 벡터** 형식으로 지정하면 된다.

예를 들어 `x`, `y`, `q` 벡터를 각각 `"First"`, `"Second"`, `"Sport"`라는 이름으로 지정하려면 다음과 같이 작성한다:

```{r}
#| eval: FALSE
df <- data.frame(Fisrt = x, Second = y, Sport = q)
```

## 2.2 데이터프레임 정보 요약하기

### 2.2.1 `nrow()`, `ncol()` 그리고 `dim()`

데이터프레임을 다루다 보면 **행과 열의 개수**를 알아야 할 일이 자주 있다.\
이럴 때 사용하는 함수가 바로 `nrow()`, `ncol()`, 그리고 `dim()` 함수이다.

-   `nrow()`는 행(row)의 개수를 반환한다.
-   `ncol()`은 열(column)의 개수를 반환한다.
-   `dim()`은 행과 열의 개수를 **벡터 형태**로 함께 반환한다.

```{r}
#| eval: FALSE
nrow(mpg)
ncol(mpg)
dim(mpg)
```

### 2.2.2 `names()`

데이터프레임의 **열 이름(column names)**을 알고 싶을 경우, 가장 간단한 방법은 `names()` 함수를 사용하는 것이다.

이 함수는 데이터프레임의 열 이름을 **문자형 벡터 형태**로 반환한다.

```{r}
#| eval: FALSE
names(mpg)
```

### 2.2.3 `str()`

`str()` 함수는 **structure(구조)**의 줄임말로,데이터 객체의 **전체 구조를 요약해서 보여주는 함수**이다.\
특히 데이터프레임이나 리스트처럼 복잡한 구조를 빠르게 파악할 때 유용하다.

```{r}
#| eval: FALSE
str(mpg)
```

### 2.2.4 `head()` 그리고 `tail()`

데이터프레임의 전체 내용을 한눈에 보기에는 행이 너무 많을 수 있다.\
이럴 때는 `head()`와 `tail()` 함수를 사용하여 **앞부분 또는 뒷부분 일부만 미리 확인**할 수 있다.

```{r}
#| eval: FALSE
head(mpg)         # 기본값: 앞 6행 출력
head(mpg, 3)      # 앞 3행 출력

tail(mpg)         # 기본값: 뒤 6행 출력
tail(mpg, 4)      # 뒤 4행 출력
```

`View()` 함수는 데이터를 엑셀처럼 새 창으로 표시하는 함수이다.

```{r}
#| eval: FALSE
View(mpg)
```

### 2.2.5 변수선택 (`$` 연산자)

데이터 프레임은 여러 개의 변수(열)가 모여 있는 형태이다. 분석을 하다 보면 전체 데이터가 아니라, "도심 연비(`cty`)의 평균만 구하고 싶다"거나 "고속도로 연비(`hwy`)만 따로 보고 싶다"는 등 특정 변수 하나만 필요할 때가 많다.

이때 사용하는 것이 바로 달러 기호(`$`)이다. `$` 연산자는 데이터 프레임 안에 있는 특정 변수(열)에 접근하는 역할을 한다.

작성 방식은 매우 간단하다. 데이터 프레임 이름 뒤에 `$`를 붙이고, 그 뒤에 원하는 변수명을 적으면 된다.

-   형식: `데이터프레임명$변수명`

-   의미: "**데이터프레임** 안에 있는(**\$**) **변수**를 꺼내라"

```{r}
#| eval: FALSE
head(mpg$cty)
```

## 2.3 데이터프레임 주요 함수

### 2.3.1 `table()` 함수

`table()` 함수는 함수는 범주형 변수의 **값의 개수(빈도수)**를 계산해주는 함수이다. `mpg`에서 `manufacturer`의 빈도

```{r}
#| eval: FALSE
table(mpg$manufacturer)
```

### 2.3.2 `colSums()`와 `colMeans()`

`colSums()`와 `colMeans()`는 각각 데이터프레임의 **각 열(column)**에 대해\
**합계(sum)**와 **평균(mean)**을 계산해주는 함수이다.

이 함수들은 **수치형(numeric)** 열에만 적용되며, **문자형 열이 포함된 경우 오류메세지가 나온다.**

```{r}
#| eval: FALSE
colSums(mpg) 
colMeans(mpg)
```

### 2.3.3 `summary()`

`summary()`함수는 데이터프레임 또는 벡터의 **각 변수(열)**에 대한\
요약 통계 정보를 빠르게 확인할 수 있는 함수이다.

-   최소값 (`Min.`)
-   1사분위수 (`1st Qu.`)
-   중앙값 (`Median`)
-   평균 (`Mean`)
-   3사분위수 (`3rd Qu.`)
-   최대값 (`Max.`)

```{r}
#| eval: FALSE
summary(mpg)
```

## 2.4 데이터프레임 인덱싱

벡터와 마찬가지로, **데이터프레임도 인덱싱을 통해 원하는 값에 접근하거나 추출**할 수 있다.\
이때 자주 사용하는 연산자가 `[]`이다.

### 2.4.1 `[]` 연산자 - 행과 열 모두 인덱싱가능

`[i, j]` 형태의 대괄호 인덱싱에서 `i`는 **행 번호**, `j`는 **열 번호**를 나타낸다.\
따라서 특정 위치의 값을 추출하고 싶을 때 이 형식을 사용할 수 있다.

예를 들어, **2행 3열**에 있는 데이터에 접근하고 싶다면 다음과 같이 작성한다:

```{r}
#| eval: FALSE
mpg[2, 3]
```

**1개 이상의 열 또는 행**을 선택하고 싶을 때는 **벡터 인덱싱**을 사용할 수 있다.\
`:` 연산자나 `c()` 함수를 이용하여 원하는 범위를 지정할 수 있다.

예를 들어, **3행의 2\~3열**을 선택하고 싶다면 다음과 같이 작성한다:

```{r}
#| eval: FALSE
mpg[3, 2:3]
mpg[3, c(2, 3)]
```

데이터프레임에서 열을 추출하고자 할 때는 `[ , j]` 형식을 사용하며,\
이때 `j` 자리에는 **열의 위치(숫자)** 또는 **열의 이름(문자열)**을 넣을 수 있다.

```{r}
#| eval: FALSE
mpg[, 3]
mpg[, 2:3]
mpg[, c("model", "displ")]
```

`[]` 형태의 인덱싱에서는 논리연산 결과를 이용한 조건 인덱싱이 가능하다. 이때 `TRUE`인 위치의 값만 추출되며, `FALSE`인 위치의 값은 제외된다.

```{r}
#| eval: FALSE
mpg$model == "a4"
mpg[mpg$model == "a4", ] 
```

데이터프레임의 변수에 접근하고자 하는경우 행렬을 다룰 때와 마찬가지로 벡터 인덱싱을 사용하거나 데이터프레임 뒤에 `$`를 붙이고 변수 이름을 작성하는 방법도 있다.

-   인덱싱을 사용하는 경우

```{r}
#| eval: FALSE
mpg[, 1]
mpg[, "manufacturer"]
```

`$`를 사용하는 경우

```{r}
#| eval: FALSE
mpg$manufacturer
```

지금의 예제에서 둘은 같은 결과를 보여주지만 특정 상황에서는 인덱싱을 사용하거나 `$`를 사용할 수 밖에 없는 상황이 존재하니 두 방법 모두 익혀두자.

`str()` 함수는 데이터프레임에 있는 변수들의 객체 유형과 관측치 개수를 파악하는 유용한 함수이다.

```{r}
#| eval: FALSE
str(mpg)
```

### 2.4.2 복합조건 인덱싱 (and, or)

두 가지 이상의 조건을 연결해야 할 때는 논리 연산자를 사용한다.

-   **AND 연산자 (`&`)**: 두 조건이 **모두** 참이어야 할 때

-   **OR 연산자 (`|`)**: 두 조건 중 **하나라도** 참이면 될 때 (`Shift` + `\` 키)

1.  **AND 조건 예시 (`&`):** 제조사가 "audi"이면서(**그리고**), 연비(cty)가 20 이상인 데이터를 추출하고 싶을 때 사용한다.

    ```{r}
    #| eval: FALSE
    # manufacturer가 "audi"이고, cty가 20 이상인 행 추출
    mpg[mpg$manufacturer == "audi" & mpg$cty >= 20, ]
    ```

2.   **OR 조건 예시 (`|`)**
    차종(class)이 "compact"이거나(**또는**), "midsize"인 데이터를 추출하고 싶을 때 사용한다.

    ```{r}
    #| eval: FALSE
    # class가 "compact" 또는 "midsize"인 행 추출
    mpg[mpg$class == "compact" | mpg$class == "midsize", ]
    ```

3.  **행 조건과 열 조건의 결합**

    마지막으로, 복합 조건으로 행을 걸러냄과 동시에 보고 싶은 열만 선택하는 방법이다.
    `[행 조건, 열 선택]` 형식을 그대로 따르면 된다.

    ```{r}
    #| eval: FALSE
    # audi 차량 중(행 조건)에서 model과 year 변수만(열 선택) 확인
    mpg[mpg$manufacturer == "audi", c("model", "year")]
    ```

### 2.5 예제

데이터 분석의 핵심은 "내가 원하는 데이터만 뽑아내서(Indexing), 그 특성을 요약(Statistics)하는 것"이다. 다음 5가지 예제를 통해 이 과정을 연습해 보자.

#### 예제 1: 특정 제조사 자동차의 연비 평균 구하기

"**Audi**에서 만든 자동차들의 **도심 연비(cty)** 평균은 얼마일까?"

1.  행 조건: `manufacturer`가 "audi"인 데이터

2.  열 선택: `cty` (도심 연비)

3.  함수: `mean()` (평균)

```{r}
#| eval: FALSE
# 1단계: audi 차량만 추출하여 audi_cars 변수에 저장
audi_cars <- mpg[mpg$manufacturer == "audi", ]

# 2단계: 추출된 데이터에서 cty 변수의 평균 계산
mean(audi_cars$cty)

# (심화) 한 줄로 작성하기
mean(mpg[mpg$manufacturer == "audi", "cty"])
```

#### 예제 2: 두 차종 간의 고속도로 연비 비교하기

"**SUV** 차량과 **Compact(경차/소형)** 차량 중 누가 고속도로 연비가 더 좋을까?"

1.  행 조건: `class`가 "suv"인 것 vs "compact"인 것

2.  열 선택: `hwy` (고속도로 연비)

3.  함수: `mean()` (평균)으로 비교

```{r}
#| eval: FALSE
# SUV 차량의 고속도로 연비 평균
suv_hwy <- mpg[mpg$class == "suv", "hwy"]
mean(suv_hwy)

# Compact 차량의 고속도로 연비 평균
compact_hwy <- mpg[mpg$class == "compact", "hwy"]
mean(compact_hwy)
```

결과를 비교해보면 일반적으로 Compact 차량의 연비가 훨씬 높게 나옵니다.

#### 예제 3: 복합 조건(AND) 데이터의 요약 통계 보기

"2000년 이후에 생산된 차량 중, **배기량(displ)이 4.0 이상**인 대형차들의 연비 분포는 어떠한가?"

1.  행 조건: `year >= 2000` **그리고(&)** `displ >= 4.0`

2.  열 선택: `cty` (도심 연비)

3.  함수: `summary()` (최소, 최대, 평균, 중위수 등 전체 요약)

```{r}
#| eval: FALSE
# 조건에 맞는 데이터를 big_engine_cars에 저장
big_engine_cars <- mpg[mpg$year >= 2000 & mpg$displ >= 4.0, ]

# 해당 차량들의 도심 연비 요약 통계 확인
summary(big_engine_cars$cty)
```

#### 예제 4: 복합 조건(OR) 데이터의 개수 세기

"제조사가 **Chevrolet**이거나 **Ford**인 미국 자동차는 이 데이터에 총 몇 대가 있을까?"

1.  행 조건: `manufacturer == "chevrolet"` **또는(\|)** `manufacturer == "ford"`

2.  함수: `nrow()` (행의 개수) 또는 `table()` (빈도표)

```{r}
#| eval: FALSE
# 쉐보레 또는 포드 자동차 추출
us_cars <- mpg[mpg$manufacturer == "chevrolet" | mpg$manufacturer == "ford", ]

# 전체 개수(행의 수) 확인
nrow(us_cars)

# (심화) 제조사별로 몇 대씩인지 나누어 보기
table(us_cars$manufacturer)
```

#### 예제 5: 특정 조건 데이터의 최댓값 찾기

"**4기통(cyl == 4)** 차량 중에서 가장 높은 고속도로 연비(hwy)는 얼마인가?"

1.  행 조건: `cyl`이 4인 데이터

2.  열 선택: `hwy` (고속도로 연비)

3.  함수: `max()` (최댓값)

```{r}
#| eval: FALSE
# 4기통 차량 데이터만 먼저 추출
cyl4_cars <- mpg[mpg$cyl == 4, ]

# 그 중에서 고속도로 연비 최댓값 확인
max(cyl4_cars$hwy)

# (참고) 최솟값은 min() 함수 사용
min(cyl4_cars$hwy)
```

## 2.5 데이터프레임 합치기

## 2.5.1 `join()`

데이터 분석을 하다 보면 **두 개 이상의 데이터프레임을 특정 기준(key)**을 기준으로\
결합해야 하는 경우가 많다. 이때 사용하는 함수가 바로 `join()`이다.

`join()` 함수는 기본적으로 **공통된 열(기준 변수)**을 기준으로 두 데이터프레임을 병합하며,\
`dplyr` 패키지에서 제공하는 다양한 종류의 `join` 함수들이 자주 사용된다.

| 함수           | 설명                                                |
|----------------|-----------------------------------------------------|
| `inner_join()` | 양쪽 모두에 존재하는 행만 결합 (교집합)             |
| `left_join()`  | 왼쪽 데이터프레임 기준, 오른쪽 값이 없으면 `NA`     |
| `right_join()` | 오른쪽 데이터프레임 기준, 왼쪽 값이 없으면 `NA`     |
| `full_join()`  | 양쪽 모든 행을 결합 (합집합), 없는 값은 `NA`로 채움 |

::: {#fig-data2}

![](./images/inner_join.png){width=40%}

Inner Join
:::

::: {#fig-data3}

![](./images/left_join.png){width=40%}

Left Join
:::

::: {#fig-data4}

![](./images/right_join.png){width=40%}

Right Join
:::

::: {#fig-data5}

![](./images/full_join.png){width=40%}

Full Join
:::


```{r}
#| eval: FALSE
students <- data.frame(id = c(1, 2, 3), name = c("Kim", "Lee", "Park"))
scores <- data.frame(id = c(1, 3, 4), score = c(90, 85, 70))

left_join(students, scores, by = "id")
```

`iris` 데이터셋은 `R`에서 기본으로 제공되는 **대표적인 내장 데이터셋** 중 하나로,\
**붓꽃(iris) 3종류에 대한 꽃받침과 꽃잎의 길이/너비** 정보를 담고 있다.

총 **150개의 관측값(행)**과 **5개의 변수(열)**로 구성되어 있으며, 각 변수는 다음과 같은 정보를 담고 있다:

| 변수 이름      | 설명                                              |
|----------------|---------------------------------------------------|
| `Sepal.Length` | 꽃받침 길이 (cm)                                  |
| `Sepal.Width`  | 꽃받침 너비 (cm)                                  |
| `Petal.Length` | 꽃잎 길이 (cm)                                    |
| `Petal.Width`  | 꽃잎 너비 (cm)                                    |
| `Species`      | 붓꽃의 품종 (`setosa`, `versicolor`, `virginica`) |

앞서 배운 `head()`, `dim()`, `str()` 등의 함수를 이용하면\
`iris` 데이터셋의 **기본 구조와 내용을 빠르게 파악**할 수 있다.

```{r}
#| eval: FALSE
head(iris)    # 상위 6행 출력 (미리 보기)
dim(iris)     # 행과 열의 개수 확인 150 5
str(iris)     # 변수의 타입과 예시 값 확인
```

### 2.5.1 `rbind()`와 `cbind()` — 행/열 결합 함수

`R`에서는 데이터프레임이나 행렬을 **행(row) 또는 열(column)** 방향으로\
결합할 때 `rbind()`와 `cbind()` 함수를 사용한다.

이를 `iris` 데이터셋을 통해 직접 살펴보자.

#### `rbind()` — 행 결합 (아래로 붙이기)

`rbind()`는 두 개 이상의 데이터프레임을 **행 방향으로 결합**한다.\
즉, **관측값(행)**을 추가하는 경우에 사용한다.

```{r}
#| eval: FALSE
new_row <- data.frame(
  Sepal.Length = 5.1,
  Sepal.Width = 3.5,
  Petal.Length = 1.4,
  Petal.Width = 0.2,
  Species = "setosa"
)

iris_extended <- rbind(iris, new_row)
nrow(iris_extended)   # 151
tail(iris_extended)
```

-   열 이름과 순서가 기존 데이터프레임과 동일해야 결합 가능

#### `cbind()` — 열 결합 (옆으로 붙이기)

`cbind()`는 두 개 이상의 벡터 또는 데이터프레임을 열 방향으로 결합한다. 즉, **새로운 변수(열)**을 추가할 때 사용한다.

```{r}
#| eval: FALSE
New_Var <- sample(1:100, 150)   # 임의의 수치형 벡터

iris_with_new <- cbind(iris, New_Var)
head(iris_with_new)
```

## 2.6 데이터프레임 서브세팅

데이터 분석에서 **서브세팅(subsetting)**은 원하는 조건에 맞는 일부 데이터만 추출하는 중요한 작업이다. 이번에는 `iris` 데이터셋을 중심으로 다양한 서브세팅 방법들을 살펴보자.

### 2.6.1 조건에 맞는 행 추출

`Species`가 `"setosa"`인 행만 추출하고 싶다면:

```{r}
#| eval: FALSE
iris[iris$Species == "setosa", ]
```

비슷하게, `Sepal.Length`가 5보다 큰 행만 추출하려면:

```{r}
#| eval: FALSE
iris[iris$Sepal.Length > 5, ]
```

### 2.6.2 `subset()` 함수 사용하기

`subset()` 함수는 조건에 맞는 행 추출을 보다 간결하게 표현할 수 있도록 도와준다.

기본형식: `subset(x, subset, select)`

-   `x`: 데이터프레임
-   `subset`: 행 필터 조건
-   `select`: 선택할 열 이름

```{r}
#| eval: FALSE
subset(iris, Species == "setosa")
subset(iris, Sepal.Length > 5)
```

다음과 같이 복수 조건을 사용할 수 있다. `|` 기호는 `R`에서 `or` 조건을, `&` 기호는 `and` 조건을 의미한다.

```{r}
#| eval: FALSE
# Species가 setosa 또는 virginica인 경우
subset(iris, Species == "setosa" | Species == "virginica")

# Species가 setosa이면서 Sepal.Length가 5보다 큰 경우
subset(iris, Species == "setosa" & Sepal.Length > 5)
```

위의 코드를 `subset()` 함수 없이 작성한다면:

```{r}
#| eval: FALSE
iris[iris$Species == "setosa" | iris$Species == "virginica", "Sepal.Length"]
```

# 3. `dplyr` 패키지

`dplyr` 패키지는 데이터프레임을 쉽고 직관적으로 다룰 수 있도록 도와주는 R의 핵심 패키지로, 열 선택, 행 필터링, 정렬, 요약, 그룹화 등 다양한 데이터 처리 작업을 간편하게 수행할 수 있다.

::: {#fig-data6}

![](./images/tidy2.png){width=80%}

Dplyr
:::


다음은 `dplyr`에서 자주 사용되는 주요 함수들이다.

| 함수          | 설명                               |
|---------------|------------------------------------|
| `filter()`    | 조건에 맞는 행만 추출              |
| `select()`    | 특정 열만 선택                     |
| `arrange()`   | 지정한 열을 기준으로 행 정렬       |
| `mutate()`    | 새로운 열 추가 또는 기존 열 변형   |
| `summarise()` | 요약 통계 계산 (예: 평균, 합계 등) |
| `group_by()`  | 그룹 단위 연산을 위해 그룹화       |
| `slice()`     | 행 번호를 기준으로 행 추출         |

이번 교육에서는 `ggplot2` 패키지에 포함된 `diamonds` 데이터를 사용한다. `diamonds` 데이터는 약 54,000개의 다이아몬드에 대한 물리적 특성과 가격 정보를 포함한 데이터셋으로, `ggplot2` 패키지에 내장되어 있어 데이터 시각화 연습에 자주 사용된다.

| 변수      | 설명                                            | 자료형         |
|---------------|------------------------------------------|---------------|
| `carat`   | 다이아몬드 무게 (캐럿)                          | numeric        |
| `cut`     | 컷 품질 (Fair, Good, Very Good, Premium, Ideal) | ordered factor |
| `color`   | 색 등급 (D\~J, D가 가장 우수)                   | ordered factor |
| `clarity` | 투명도 등급 (I1\~IF, IF가 가장 우수)            | ordered factor |
| `depth`   | 전체 깊이 비율 = z / mean(x, y)                 | numeric        |
| `table`   | 테이블 비율 = x축 기준 윗면 폭 비율             | numeric        |
| `price`   | 가격 (USD)                                      | integer        |
| `x`       | 길이 (mm)                                       | numeric        |
| `y`       | 너비 (mm)                                       | numeric        |
| `z`       | 깊이 (mm)                                       | numeric        |

## 3.1 파이프 연산자

`dplyr`에서 자주 사용되는 파이프 연산자 (`%>%`)는 여러 연산을 연결한 문법으로 표현 할 수 있게 해주는 핵심 도구이다.

`%>%`는 앞에서 수행한 결과를 다음 함수의 첫 번째 인자로 전달하는 연산자로 복잡한 중첩 함수 호출 없이 가독성 좋고 직관적인 코드를 작성하기 위해 사용된다.

기본 사용 형태

data %\>% function1() %\>% function2() %\>% function3()

이는 아래와 동일한 의미이다.

function3(function2(function1(data)))

다음의 예제는 같은 결과를 보여주는 코드이다. 첫 번째는 파이프 연산자를 사용한 방식이고, 두 번째는 파이프 없이 중첩 함수 호출로 작성한 방식이다.

```{r}
#| eval: FALSE
x <- 1:10

sum(x)
x %>% 
  sum()
```

`%>%`는 `ctrl` + `shift` + `M` 단축키로 쉽게 불러올 수 있다.

## 3.2 `select()`

`select()` 함수는 데이터프레임에서 원하는 열(column)만 선택할 수 있도록 해주는 함수이다,

### 주요 사용 예시

`diamonds` 데이터를 이용하여 `carat`과 `price` 열을 선택해보자.

```{r}
#| eval: FALSE
select(diamonds, carat, price)
```

이번에는 파이프 연산자 `%>%`를 이용해 같은 작업을 수행해보자.

```{r}
#| eval: FALSE
diamonds %>% 
  select(carat, price)
```

`c()` 함수를 이용해서 열을 선택할 수도 있다.

```{r}
#| eval: FALSE
diamonds %>% 
  select(c(carat, price))
```

열의 위치를 인덱스하여 `select()` 함수를 이용할 수도 있다.

```{r}
#| eval: FALSE
diamonds %>% 
  select(1, 7)
```

`c`로 시작하는 열만 선택하고자 할 때는 `starts_with()` 함수를 사용한다. 이 경우 `carat`, `cut`, `color`, `clarity` 열이 선택된다.

```{r}
#| eval: FALSE
diamonds %>% 
  select(starts_with("c"))
```

`contains()` 함수는 열 이름에 특정 문자열이 포함된 모든 열을 선택할 때 사용한다. 예를 들어 `"l"`이 포함된 열을 선택하면 `color`, `clarity`, `table`이 선택된다.

```{r}
#| eval: FALSE
diamonds %>% 
  select(contains("l"))
```

`-`는 특정 열을 제외할 때 사용하는 연산자이다. 예를 들어 `-c(carat, price)`를 사용하면 `carat`과 `price`를 제외한 나머지 열이 선택된다.

```{r}
#| eval: FALSE
diamonds %>% 
  select(-carat, -price)
```

## 3.3 `filter()`

`filter()` 함수는 조건에 맞는 행(row)만 추출할 때 사용하는 함수이다.\
즉, 데이터프레임에서 원하는 조건을 만족하는 행만 선택하고 나머지는 제거된다.

#### 자주 사용하는 논리 연산자:

-   `==` : 같다\
-   `!=` : 같지 않다\
-   `>` : 초과\
-   `<` : 미만\
-   `>=` : 이상\
-   `<=` : 이하\
-   `&` : 그리고 (AND)\
-   `|` : 또는 (OR)\
-   `!` : 부정 (NOT)

### 주요 사용 예시

`diamonds` 데이터에서 `cut`이 `"Ideal"`인 행만 추출하고 싶은 경우, `filter()` 함수를 다음과 같이 사용한다:

```{r}
#| eval: FALSE
diamonds %>% 
  filter(cut == "Ideal")
```

`%in%`은 여러 값을 동시에 조건으로 지정하고 싶을 때 사용하는 연산자이다.\
특히 `filter()` 함수와 함께 쓰면, 여러 값 중 하나라도 일치하는 행을 선택할 수 있다.

```{r}
#| eval: FALSE
diamonds %>% 
  filter(cut %in% c("Ideal", "Good"))
```

다음과 같은 논리 연산자를 이용해서도 조건에 따라 데이터를 필터링할 수 있다.\
예를 들어, `price`가 1000을 초과하는 행만 추출하고 싶다면 다음과 같이 작성한다:

```{r}
#| eval: FALSE
diamonds %>%
  filter(price >= 1000)
```

`price`가 1000이 아닌 모든 행을 추출하고자 한다면.

```{r}
#| eval: FALSE
diamonds %>% 
  filter(price != 1000)
```

`carat`이 2보다 크고 `price`가 14000보다 작은 행을 추출하고자 한다면

```{r}
#| eval: FALSE
diamonds %>% 
  filter(carat > 3 & price < 14000)
```

`carat`이 1보다 작거나 5보다 큰 행만 추출하고자 한다면

```{r}
#| eval: FALSE
diamonds %>% 
  filter(carat < 1 | carat > 5)
```

## 3.4 `slice()`

`slice()` 함수는 `filter()`와는 달리 조건이 아닌 행 번호(index 또는 위치)를 기준으로 행을 선택할 때 사용하는 함수이다. 즉, 데이터프레임에서 특정 위치에 있는 행만 선택하고 나머지는 제거된다.

```{r}
#| eval: FALSE
diamonds %>% 
  slice(1:5)
```

또는 `c()` 형태로도 행을 선택할 수 있다.

```{r}
#| eval: FALSE
diamonds %>% 
  slice(c(1:5, 8, 15:20))
```

1행을 제외한 모든 행을 선택하고자 하는경우는 다음과 같이 한다.

```{r}
#| eval: FALSE
diamonds %>% 
  slice(-1)
```

## 3.5 `mutate()`

`mutate()` 함수는 기존 열을 변형하거나 새로운 열을 추가할 때 사용하는 함수이다. 데이터프레임에 새로운 변수(column)를 생성하거나 기존 변수의 값을 바꿀 수 있는 함수이다.

예를 들어, `price/carat`의 비율을 나타내는 새로운 열을 만들어보자:

```{r}
#| eval: FALSE
diamonds %>% 
  mutate(price/carat)
```

하지만 이 코드만으로는 열의 이름이 지정되지 않았고, 열이 너무 많아서 출력 시 새로 만든 열이 보이지 않을 수 있다. 이럴 때는 앞에서 배운 `select()` 함수를 사용해 관심 있는 열만 선택한 뒤, `mutate()`로 새 열을 추가하면 더 명확하게 확인할 수 있다.

```{r}
#| eval: FALSE
diamonds %>% 
  select(carat, price) %>% 
  mutate(price/carat)
```

이제 새로 만든 열에 `Ratio`라는 이름을 부여해보자:

```{r}
#| eval: FALSE
diamonds %>% 
  select(carat, price) %>% 
  mutate(Ratio = price/carat)
```

여기서 `Ratio` 값을 이용해 새로운 열을 연쇄적으로 만들 수도 있다. 예를 들어, `Ratio`에 2를 곱한 값을 `Double`이라는 이름으로 추가하면 다음과 같다:

```{r}
#| eval: FALSE
diamonds %>% 
  select(carat, price) %>% 
  mutate(Ratio = price/carat,
         Double = Ratio*2)
```

이처럼 `mutate()`는 다른 열을 조합하거나 가공하여 여러 새로운 변수들을 동시에 생성하는 데 매우 유용하다.

여기서 중요한 점은, `%>%`, `mutate()` 등과 같은 함수들을 사용해 데이터를 처리하더라도 원본 데이터는 실제로 변경되지 않는다는 것이다. diamonds 데이터프레임 자체는 그대로 유지되고, 변형된 결과는 일시적으로 출력될 뿐이다.

따라서, 우리가 만든 새로운 데이터를 보존하여 나중에 다시 사용하고 싶다면, 결과를 새로운 객체에 할당해주어야 한다.

```{r}
#| eval: FALSE
dia_ratio <- diamonds %>% 
  select(carat, price) %>% 
  mutate(Ratio = price/carat,
         Double = Ratio*2)
```

## 3.6 `summarize()`

`summarize()` 함수(또는 `summarise()`)는 데이터의 요약 통계량을 계산할 때 사용하는 함수이다. 데이터프레임 전체 또는 그룹별로 평균, 합계, 개수, 최대값, 최소값 등을 계산할 때 사용된다.

예를 들어, `diamonds` 데이터프레임에서 `price`의 평균을 계산하려면 다음과 같이 작성할 수 있다:

```{r}
#| eval: FALSE
diamonds %>% 
  summarize(mean(price))
```

`summarize()` 함수에서는 평균뿐 아니라 다양한 통계량 계산도 간단히 수행할 수 있다:

```{r}
#| eval: FALSE
diamonds %>% 
  summarize(AvgPrice = mean(price),
            MedianPrice = median(price),
            Avgcarat = mean(carat))
```

`summarize()`는 단독으로도 사용할 수 있지만, `group_by()`와 함께 사용하면 그룹별 통계량을 계산하는 데 특히 유용하다.

## 3.7 `group_by()`

`group_by()` 함수는 데이터를 특정 변수(또는 변수들)를 기준으로 그룹화할 때 사용하는 함수이다. 이 함수는 보통 `summarize()`와 함께 사용되어, 각 그룹별로 요약 통계량을 계산할 수 있게 한다.

예를 들어, `cut`의 종류별로 `price`의 평균을 계산하려면 다음과 같이 작성한다:

```{r}
#| eval: FALSE
diamonds %>% 
  group_by(cut) %>% 
  summarize(AvgPrice = mean(price))
```

이번에는 `cut`과 `color` 두 가지 기준으로 그룹화한 후, `price`의 평균과 `carat`의 합계를 함께 계산해보자:

```{r}
#| eval: FALSE
diamonds %>% 
  group_by(cut, color) %>% 
  summarize(AvgPrice = mean(price), SumCarat = sum(carat))
```

조금 더 나아가서, 이 중 `cut` == `"Fair"`인 그룹만 추출하고 싶다면 다음과 같이 작성한다:

```{r}
#| eval: FALSE
diamonds %>% 
  group_by(cut, color) %>% 
  summarize(AvgPrice = mean(price), SumCarat = sum(carat)) %>% 
  filter(cut == "Fair")
```

## 3.8 `arrange()`

`arrange()` 함수는 데이터를 특정 변수(열)의 값을 기준으로 정렬할 때 사용하는 함수이다. 기본적으로 오름차순 정렬을 수행하며, desc() 함수를 함께 사용하면 내림차순 정렬도 가능하다.

```{r}
#| eval: FALSE
diamonds %>% 
  group_by(cut) %>% 
  summarize(AvgPrice = mean(price), SumCarat = sum(carat)) %>% 
  arrange(AvgPrice)
```

```{r}
#| eval: FALSE
diamonds %>% 
  group_by(cut) %>% 
  summarize(AvgPrice = mean(price), SumCarat = sum(carat)) %>% 
  desc(AvgPrice)
```

지금까지 배운 함수를 이용하여 다음과 같은 분석을 수행해보자.

-   cut이 `"Ideal"` 또는 `"Premium"`인 다이아몬드 중에서
-   `carat`, `price`, `cut`, `color` 변수만 선택하고
-   `price` 대비 `carat` 비율(`carat_per_dollar`)을 계산한 후
-   `cut`과 `color`별로 그룹화하여
-   `carat_per_dollar`의 평균과 최대값을 구하고
-   평균이 높은 순서대로 정렬한다


# 4. ggplot2의 이해와 활용

## 왜 ggplot2를 쓰는가

R의 기본 그래픽(`plot()`)만으로도 시각화는 가능하다. 다만 그림이 조금만 복잡해져도 **수정/확장**이 불편해진다.  
예를 들어 색, 범례, 조건별 비교(facet), 통계적 요약(추세선) 등을 추가하려면 옵션을 하나씩 수동으로 만져야 한다.

반면 `ggplot2`는 **그래픽 문법(grammar of graphics)**에 기반해, 그림을 **레이어(layer)**로 쌓아 올리는 방식으로 작성한다.  
그래서 다음과 같은 장점이 생긴다.

- 코드 구조가 일정해 **재사용/수정/확장**이 쉽다.
- 변수와 시각적 속성(aes)을 연결해 **일관된 표현**이 가능하다.
- `facet`, `theme`, `scale` 같은 기능으로 **표현을 체계적으로 확장**한다.
- `dplyr`로 집계한 결과를 그대로 이어서 시각화하기 좋다.

### 기본 plot vs ggplot2 

```{r}
# base plot
plot(mpg$displ, mpg$hwy,
     main = "base plot: displ vs hwy",
     xlab = "displ", ylab = "hwy",
     pch = 20, col = "blue")
```

```{r}
# ggplot2
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  labs(title = "ggplot2: displ vs hwy")
```

---

## 강의 목표

이번 실습에서는 `ggplot2`의 기본 문법을 `mpg` 데이터로 익힌다.

- `ggplot(data) + aes(...) + geom_*()` 기본 구조를 이해한다
- 산점도/막대그래프/박스플롯의 핵심 문법을 실습한다
- `facet_*`, `theme`, `scale_*`로 표현을 확장한다
- `dplyr` 집계 후 시각화까지 연결한다

---

## 4.0 패키지 로드와 데이터 확인

```{r}
library(ggplot2)
library(dplyr)

head(mpg)
str(mpg)
```

`mpg` 데이터는 자동차 연비 관련 데이터다.

- `displ`: 엔진 배기량
- `hwy`: 고속도로 연비
- `cty`: 도심 연비
- `class`: 차종
- `drv`: 구동방식

---

## 4.1 ggplot2의 기본 구조

`ggplot2`는 보통 아래 형태로 작성한다.

- `ggplot(data = ...)` : 사용할 데이터
- `aes(...)` : 매핑(미적 요소: x, y, color, size 등)
- `geom_*()` : 기하 객체(점/선/막대/상자그림 등)

### 4.1.1 가장 기본: 산점도

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point()
```

---

## 4.2. 미적요소(aes) 확장: 색/투명도

### 4.2.1 범주형 변수를 색으로

```{r}
ggplot(mpg, aes(x = displ, y = hwy, color = class)) +
  geom_point()
```

### 4.2.2 점 겹침 완화: 투명도(alpha)

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(alpha = 0.5)
```

> `alpha`는 0~1 사이 값이며, 값이 작을수록 더 투명해진다.

---

## 4.3. 레이어 추가: 추세선(geom_smooth)

### 4.3.1 전체 추세선(비선형 스무딩)

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(alpha = 0.6) +
  geom_smooth(se = TRUE)
```

### 4.3.2 선형회귀 추세선(method = "lm")

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = TRUE)
```

---

## 4.4. facet으로 그룹 비교

### 4.4.1 차종별로 나누어 보기

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(alpha = 0.6) +
  facet_wrap(~ class)
```

### 4.4.2 구동방식별로 나누어 보기

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(alpha = 0.6) +
  facet_wrap(~ drv)
```

---

## 4.5. 범주형 그래프: 막대그래프 / 박스플롯

### 4.5.1 막대그래프(빈도)

`geom_bar()`는 기본적으로 **개수(count)**를 센다.

```{r}
ggplot(mpg, aes(x = class)) +
  geom_bar()
```

레이블이 겹치면 회전해서 가독성을 높인다.

```{r}
ggplot(mpg, aes(x = class)) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### 4.5.2 박스플롯: 차종별 고속도로 연비 분포

```{r}
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

점도 같이 찍으면 분포가 더 직관적으로 보인다.

```{r}
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_boxplot(outlier.alpha = 0.2) +
  geom_jitter(width = 0.15, alpha = 0.4) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

---

## 4.6. 집계 후 시각화: dplyr + ggplot2

### 4.6.1 차종별 평균 hwy 계산

```{r}
mpg_sum <- mpg %>%
  group_by(class) %>%
  summarise(
    mean_hwy = mean(hwy),
    n = n(),
    .groups = "drop"
  )

mpg_sum
```

### 4.6.2 평균 연비 막대그래프(geom_col)

`geom_col()`은 y값을 **그대로 사용**한다(집계된 데이터에 적합하다).

```{r}
ggplot(mpg_sum, aes(x = class, y = mean_hwy)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### 4.6.3 값 기준 정렬(reorder) + 가독성(축 뒤집기)

```{r}
ggplot(mpg_sum, aes(x = reorder(class, mean_hwy), y = mean_hwy)) +
  geom_col() +
  coord_flip() +
  labs(
    x = "class",
    y = "평균 고속도로 연비(mean hwy)",
    title = "차종별 평균 고속도로 연비(정렬)"
  )
```

---

## 4.7. 라벨/제목/범례 설정: labs

```{r}
ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_point(alpha = 0.7) +
  labs(
    title = "배기량과 고속도로 연비의 관계",
    subtitle = "구동방식(drv)별로 색상 구분",
    x = "배기량(displ)",
    y = "고속도로 연비(hwy)",
    color = "구동방식"
  )
```

---

## 4.8. 테마(theme): 전체 스타일 바꾸기

대표적으로 많이 쓰는 테마는 다음과 같다.

- `theme_minimal()`
- `theme_bw()`
- `theme_classic()`

```{r}
ggplot(mpg, aes(x = displ, y = hwy, color = class)) +
  geom_point(alpha = 0.7) +
  theme_minimal()
```

---

## 4.9. 스케일(scale): 축 변환/범위 조정

### 4.9.1 y축 범위 제한(주의: 범위 밖 데이터는 잘린다)

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(alpha = 0.7) +
  scale_y_continuous(limits = c(10, 40))
```

### 4.9.2 로그 스케일(분포가 한쪽으로 치우친 경우)

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(alpha = 0.7) +
  scale_x_log10()
```
---

## 4.10. 저장하기: ggsave

```{r}
p <- ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_point(alpha = 0.7) +
  theme_minimal()

p
```

```{r}
#| eval: FALSE
ggsave("mpg_scatter.png", plot = p, width = 7, height = 5, dpi = 300)
```

---

## 4.11. 연습문제

### 연습 1
`cty`(도심연비)와 `hwy`(고속도로연비)의 관계를 산점도로 그리고, `class`로 색을 구분해보자.

힌트:
- `aes(x = cty, y = hwy, color = class)`
- `geom_point()`

### 연습 2
`class`별 `hwy`의 분포를 박스플롯으로 그린 뒤, x축 레이블 겹침을 해결해보자.

힌트:
- `theme(axis.text.x = element_text(angle = 45, hjust = 1))`

### 연습 3
`drv`별 평균 `hwy`를 계산한 뒤 막대그래프로 나타내보자.

힌트:
- `group_by(drv) %>% summarise(mean_hwy = mean(hwy))`
- `geom_col()`

---

## 요약

- `ggplot(data) + aes(...) + geom_*()`는 기본 뼈대다.
- `+`로 레이어를 쌓아 의미를 확장한다.
- 범주 비교는 `facet`, 스타일은 `theme`, 축/표현은 `scale`로 다룬다.
- 실무에서는 `dplyr`로 집계 후 `geom_col()` 조합을 자주 쓴다.



연습 1: cty vs hwy 산점도 + class로 색 구분
ggplot(mpg, aes(x = cty, y = hwy, color = class)) +
  geom_point(alpha = 0.7) +
  labs(
    title = "cty vs hwy (class로 색 구분)",
    x = "cty (도심 연비)",
    y = "hwy (고속도로 연비)",
    color = "class"
  )

연습 2: class별 hwy 박스플롯 + x축 레이블 겹침 해결
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_boxplot(outlier.alpha = 0.3) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    title = "class별 hwy 분포(박스플롯)",
    x = "class",
    y = "hwy"
  )

연습 3: drv별 평균 hwy 계산 후 막대그래프(geom_col)
mpg_drv <- mpg %>%
  group_by(drv) %>%
  summarise(mean_hwy = mean(hwy), .groups = "drop")

ggplot(mpg_drv, aes(x = drv, y = mean_hwy)) +
  geom_col() +
  labs(
    title = "drv별 평균 hwy",
    x = "drv",
    y = "mean(hwy)"
  )


# 5. 국민체력 100 자료를 이용한 데이터 분석 예제

## 필요한 패키지

다음은 본 예제를 실행하는 데 필요한 R 패키지들이다. 패키지가 설치되어 있지 않은 경우에는 먼저 설치한 후 로드한다.

```{r}
#| warning: false
#| message: false

library(tidyverse) # 데이터 처리 및 시각화 패키지
library(lubridate) # 날짜 처리 패키지
library(stringr) # 문자열 처리 패키지
library(readxl) # 엑셀 파일 읽기 위한 패키지
#library(openxlsx) # 엑셀 파일 읽기 위한 패키지
library(flextable) # 표 작성 패키지
library(here) # 파일 경로 설정을 위한 패키지

# ggplot 으로 그림을 그릴 때 한글이 깨지지 않게 폰트 Nanum Pen Script를 선택
library(showtext)
font_add_google("Nanum Pen Script", "gl")
showtext_auto()
```


## 개요 

국민체력 100 사업은 국민의 기초체력을 증진시키기 위하여 국민체력 측정 및 평가, 운동처방, 체력증진 프로그램 운영 등을 실시하는 사업이다.
이 사업을 통해 수집된 자료는 국민의 체력 수준을 파악하고, 체력 증진을 위한 다양한 프로그램을 개발하는 데 활용된다. 
본 예제에서는 국민체력 100 자료를 이용하여 데이터에 대한 전처리 및 기초 분석과 시각화를 수행하는 방법을 다룬다.

마지막으로 체력 측정 자료와 등급 기준 자료를 결합하여 보고서에 사용할 수 있는 요약표와 그래프를 만드는 실습을 수행한다. 


## 데이터 불러오기 

### 데이터 파일 개요 

이 예제에서는 다음과 같은 3 개의 엑셀 파일에 저장된 데이터를 사용할 것이다.

- `sample_data_sports100.xlsx`: 
  + 국민체력 100 사업에서 측정 데이터로 인구통계적 변수와 체력 측정항목으로 구성된 자료
  + 13세-18세의 청소년 자료로서 1000명의 표본자료
  
- `columns_info.xlsx`: 
  + 국민체력 100 측정 데이터의 각 변수에 대한 설명이 포함된 자료
  + 변수명, 변수 설명, 단위 등의 정보가 담겨 있다.
  + 각 측정 항목에 대한 측정 가능한 범위에 대한 최소값과 최대값이 포함되어 있다. 

- `class_level.xlsx`: 
  + 국민체력 100 측정 데이터의 각 체력 측정항목에 대한 등급 기준이 포함된 가상의 자료
  + 측정항목에 대하여 연령대별, 성별로 30, 50, 70 백분위수가 저장되어 있다.
  + 편의상 해당 측정항목이 30% 백분수 미만이면 4등급, 30%-50% 이면 3등급, 50%-70% 이면 2등급, 70% 이상이면 1등급 

::: {.callout-note}

### 분위수란?

분위수(quantile) 는 자료를 크기 순으로 정렬했을 때, 전체를 일정한 비율로 나누는 기준값을 말한다. 예를 들어 중앙값(50% 분위수) 은 자료의 절반이 그 값 이하가 되도록 하는 지점이며, 사분위수(25%, 50%, 75%) 는 자료를 네 구간으로 나누는 기준값이다. 분위수를 활용하면 평균처럼 일부 극단값의 영향을 크게 받지 않으면서도, 자료의 분포와 개인의 상대적 위치를 직관적으로 파악할 수 있다.

:::

다음은 위에서 설명한 3개의 엑셀파일의 일부를 나타낸 그림이다.

::: {#fig-data1}

![`sample_data_sports100.xlsx`](./images/data_1.png){width=80%}

국민체력 100 사업의 측정 데이터
:::


::: {#fig-data2}

![`column_info.xlsx`](./images/data_2.png){width=80%}

국민체력 100 측정 데이터의 설명 자료
:::


::: {.callout-note}

### 변수 정보 자료 

많은 종류의 자료를 관리하는 경우 각 항목의 이름을 의미가 있는 영문명이나 한글명으로 관리하는 것은 복잡한 작업이다. 우리가 위에서 본 국민체력100에 대한 자료에서 관측값을 저장하는 `sample_data_sport100.xlsx` 에서는 변수명을 `ITEM_XXX` 와 같이 번호가 붙은 컬럼명을 사용한다.

더 나아가 별도의 자료  `columns_info.xlsx` 는 변수명 `ITEM_XXX` 에 대한 한글이름, 체력 측정에 대한 부문, 단위, 정상값 범위 등 측정항목에 대한 정보(즉 메타 정보; Meta Infomation)를 포함한다.

이렇게 측정값을 저장하는 데이터와 측정항목의 정보를 저장하는 데이터를 따로 관리하고 서료 결합할 수 있게 하면 자료의 확정성이 커지고 관리가 편리하다.

:::


::: {#fig-data3}

![`class_level.xlsx`](./images/data_3.png){width=80%}


국민체력 100 측정 데이터의 등급 기준 자료 
:::

### 데이터 불러오기 

이제 `R`을 이용하여 위에서 설명한 3 개의 엑셀 파일을 불러오자. 이를 위해 `readxl` 패키지의 함수 `read_xlsx`를 사용한다.
함수 `read_xlsx` 에서 사용된 `col_names = TRUE` 선택문은 엑셀파일의 첫 번째 행의 내용을 컬럼의 이름으로 하기위한 선택문이다. 

```{r}
# 데이터 불러오기
df_data <- read_xlsx(here("data", "sample_data_sports100.xlsx"), col_names = TRUE)
df_col_info <- read_xlsx(here("data", "column_info.xlsx"), col_names = TRUE)
df_class_level <- read_xlsx(here("data", "class_level.xlsx"), col_names = TRUE)
```

::: {.callout-note}

### `here()` 함수 설명

`here()` 함수는 R 프로젝트에서 파일 경로를 쉽게 관리할 수 있도록 도와주는 함수이다. 이 함수는 프로젝트의 루트 디렉토리를 기준으로 상대 경로를 생성하여, 파일을 불러오거나 저장할 때 편리하게 사용할 수 있다.

예를 들어, `here("data", "sample_data_sports100.xlsx")`는 현재 R 프로젝트의 루트 디렉토리에서 `data` 폴더 안에 있는 `sample_data_sports100.xlsx` 파일의 경로를 생성한다. 이를 통해 코드가 다른 컴퓨터나 환경에서 실행될 때도 파일 경로 문제를 최소화할 수 있다.

:::

이제 불러온 자료의 일부와 구조를 살펴보면서 자료가 정확하게 데이터프레임으로 만들어졌는지 살펴보자.

```{r}
head(df_data)
head(df_col_info)
head(df_class_level)
```


## 데이터 전처리 

먼저 함수 `glimpse` 을 이용하여 측정 자료 `df_data` 의 각 컬럼들이 어떠한 형식으로 입력되어 있는지 살펴보자 

```{r}
glimpse(df_data)
```

먼저 연령을 나타내는 컬럼 `TEST_AGE` 가 실수형(double)으로 입력되어 있으므로 편의상 정수형(integer) 로 변환하자.

```{r}
df_data <- df_data %>%
  mutate( TEST_AGE = as.integer(TEST_AGE))
```


### 날짜 변수의 생성

먼저 데이터프레임 `df_data` 에서  `TEST_MD` 컬럼은 측정 날짜를 나타내는 데이터이지만 엑셀 파일에서 자료 입력시 문자형 변수로 입력이 된다. 일반적으로 날짜를 나타내는 자료는 날짜형 변수로 형식을 바꾸는 것이 다루기 편하다.

```{r}
glimpse(df_data$TEST_MD)

df_data <- df_data %>%
  mutate(
    TEST_MD = ymd(TEST_MD)
  )

glimpse(df_data$TEST_MD)
```


다음으로 측정 년도를 나타내는 새로운 변수 `TEST_YEAR` 를 함수 `year` 를 이용하여 생성하고, 다시 범주형으로 변환하여 컬럼의 위치를 `TEST_MD` 뒤에 있도록 하자. 일반적으로 년도를 나타내는 변수는 정수형이지만 범주형으로 사용하는 것이 편리하다. 

```{r}
df_data <- df_data %>%
  mutate(TEST_YEAR = factor(year(TEST_MD))) %>%
  relocate(TEST_YEAR, .after = TEST_MD)
```


### 범주형 변수의 변환 

다음으로 성별을 나타내는 `TEST_SEX` 변수의 값이 `M`이면  `남성`, `F`이면 `여성` 으로 문자형으로 바꾸고 범주형 변수(factor)로 변환하자.

또한 생애 주기를 나타내는 변수 `AGE_GBN` 범주형 변수로 변환하자. 이 경우 `levels` 선택문을 사용하여 항목의 순서를 `청소년`, `성인`, `어르신` 순서로 지정할 수 있다. 

```{r}
df_data <- df_data %>%
  mutate(TEST_SEX = case_when(
      TEST_SEX == "M" ~ "남성", 
      TEST_SEX == "F" ~ "여성")) %>% 
  mutate( TEST_SEX = factor(TEST_SEX, levels = c("남성", "여성"))) %>%
  mutate( AGE_GBN = factor(AGE_GBN, levels = c("청소년", "성인",   "어르신")))

glimpse(df_data)
```

::: {.callout-note}

### `case_when` 함수 설명

`case_when()`은 여러 조건에 따라 값을 나누어 지정할 때 사용하는 함수이다. 조건문을 여러 번 쓰는 대신, 조건을 위에서부터 순서대로 검사하여 **처음으로 TRUE가 되는 값**을 반환한다.

:::


## 기술 통계 분석

###  범주형 자료의 분포 

먼저 2000명의 사랍들을 연도별, 성별, 생애주기별 도수 분포표를 만들어 보자. 가장 기본적인 범주형 자료의 분포를 만들 수 있는 함수는 `table` 함수이다.

```{r}
table(df_data$TEST_YEAR)
table(df_data$TEST_SEX)
table(df_data$AGE_GBN)
```

다음과 같이 함수 `table` 을 이용하여 2개의 변수에 대한 교차표(cross table) 도 만들 수 있다.

```{r}
table( df_data$TEST_SEX, df_data$TEST_YEAR)
```

`table` 함수로 만든 교차표를 데이터프레임으로 바꾸면 다음과 같은 형식의 자료가 생성된다.

```{r}
as.data.frame( table( df_data$TEST_SEX, df_data$TEST_YEAR))
```


`table` 함수는 간단하게 범주형 변수의 분포를 파악하는 데 유용하지만, `dplyr` 패키지를 이용하면 보다 유연하게 다양한 형태의 요약표를 만들 수 있다. 이제 `dplyr` 패키지의 `group_by` 와 `summarise` 함수를 이용하여 범주형 변수의 분포를 요약한 표를 만들어 보자. 교차표에 연도별 남녀의 비율을 추가하는 코드도 추가해보자. 

```{r}
cross_tbl_01 <- df_data %>%
  group_by(TEST_YEAR, TEST_SEX) %>%
  summarise(n = n(), .groups = "drop_last") %>%
  mutate(percent = n / sum(n) * 100 ) 

cross_tbl_01
```

::: {.callout-note}

#### `summarise()` 함수의 `.groups` 인자 설명

`summarise()` 함수의 `.groups` 인자는 요약된 결과 데이터프레임에서 그룹화된 변수를 어떻게 처리할지를 지정하는 역할을 한다. 이 인자는 다음과 같은 옵션들을 가질 수 있다:

- `"drop"`: 모든 그룹화를 제거하고 결과를 단일 데이터프레임으로 반환한다.
- `"drop_last"`: 마지막 그룹화 변수만 제거하고 나머지 그룹화 변수는 유지한다.
- `"keep"`: 모든 그룹화 변수를 유지한다.
- `"rowwise"`: 결과를 행 단위로 그룹화한다.
:::

다음과 같이 `.groups = "drop_last"` 를 이용한 결과를 위의 결과와 비교해보자. 위에서 처럼 `.groups = "drop_last"` 를 이용하면  `summarise` 함수에서  마지막 그룹화 변수인 `TEST_SEX` 만 제거되고, `TEST_YEAR` 는 여전히 그룹화된 상태로 유지된다. 따라서 결과 데이터프레임은 `TEST_YEAR` 별로 요약된 형태로 나타난다. 반면, `.groups = "drop"`을 사용하면  그룹화 정보가 모두 제거되어 비율은 전체 자료 기준으로 계산된다.

```{r}
cross_tbl_02 <- df_data %>%
  group_by(TEST_YEAR, TEST_SEX) %>%
  summarise( n = n(), .groups = "drop") %>%
  mutate( percent = n / sum(n) * 100 ) 

cross_tbl_02
```

### 연속형 자료의 요약

다음으로 연속형 변수들의 요약 통계량을 계산해 보자. 이를 위해 `dplyr` 패키지의 `summarise` 함수를 이용하여 각 변수에 대한 평균, 표준편차, 최소값, 최대값 등을 계산할 수 있다. 예를 들어, 연도별, 성별로 신장(`ITEM_F001`)에 대한 요약 통계량을 계산하는 코드는 다음과 같다.


```{r}
summary_stats_1 <- df_data %>%
   group_by(TEST_YEAR, TEST_SEX) %>%
  summarise(
    height_mean = mean(ITEM_F001, na.rm = TRUE),
    height_sd = sd(ITEM_F001, na.rm = TRUE), 
     .groups = "keep")

summary_stats_1
```

더 나아가 여러 개의 변수들에 대하여 요약 통계량을 한꺼번에 계산하려면 `across` 함수를 사용할 수 있다. 예를 들어, 신장(`ITEM_F001`), 몸무게(`ITEM_F002`), 체지방률(`ITEM_F003`)에 대한 요약 통계량을 한꺼번에 계산하는 코드는 다음과 같다.

```{r}
summary_stats_2 <- df_data %>%
  group_by(TEST_YEAR, TEST_SEX) %>%
  summarise(
    across(c(ITEM_F001, ITEM_F002, ITEM_F003), 
      list(mean = ~ mean(.x, na.rm = TRUE),
           sd = ~ sd(.x, na.rm = TRUE),
           min = ~ min(.x, na.rm = TRUE),
           max = ~ max(.x, na.rm = TRUE)
      ),
    .names = "{.col}-{.fn}"
    ),
    .groups = "keep"
  )

summary_stats_2
```


::: {.callout-note}

#### `flextable` 의 이용 

데이터프레임을 출력하는 경우 표 형식(tbale format)으로 보기 좋게 출력하려면 `flextable` 함수를 사용하면 된다.  패키지 `flextable` 포함된 `flextable` 과 `autofit` 두 함수를 사용하면 보기 편한 표 형식으로 데이터를 출력할 수 있다. 

:::

이제 위에서 구한 데이터프레임 `summary_stats_2` 의 일부를 `flextable` 함수를 이용하여 출력해보자.

```{r}
head(summary_stats_2, 20) %>%
  flextable() %>%
  autofit()
```




### 자료의 형태 변환

::: {.callout-note}

#### 넓은 형식와 긴 형식의 자료


- **넓은 형식의 자료(wide format data)**
  + 하나의 개체에 해당하는 값들이 한 행으로 구성
  + 보고서 및 요약표 작성에 적합

::: {#fig-wide}

![](./images/wide_format.png){width=50%}

넓은 형식의 자료 
:::

- **긴 형식의 자료(long format data)**
  + 하나의 개체에 해당하는 값들이 여러 개의 행으로 구성
  + 통계 분석 및 시계열 분석에 적합

::: {#fig-long}

![](./images/long_format.png){width=30%}

긴 형식의 자료 
:::

두 형식은 두 함수 `pivot_wider` 와 `pivot_longer` 로 서로 변환할 수 있다.

:::

위의 결과는 각 변수의 통계량(평균, 표준편차, 최소값, 최대값)이 컬럼 형태로 저장된 **넓은 형태의 자료(wide format data)**이다. 이제  통계량의 값을 하나의 컬럼에 저장하는 **긴 형태의 자료(long format data)** 로 바꾸어 보자. 이를 위해 `pivot_longer` 함수를 사용한다.

```{r}
summary_stats_3 <- summary_stats_2 %>%
  pivot_longer(
    cols = starts_with("ITEM"),
    names_sep = "-", 
    names_to = c("varname_eng", "stat"),
    values_to = "value"
  )

head(summary_stats_3, 20) %>%
  flextable() %>%
  autofit()
```

### 재코딩 및 변수 이름 바꾸기


다음으로 긴 형태의 자료(long format data)에서 `ITEM` 변수에 저장된 측정 항목의 변수명을 `df_col_info` 에 저장된 한글 측정 항목의 이름으로 바꾸어 작업을 다음과 같이 할 수 있다.

먼저 `df_col_info` 에서 영문 항목 이름(`varname_eng`) 과 한글 항목 이름(`varname_kor`) 를 선택하고 위에서 만든 `summary_stats_3` 에 있는 영문 항목 이름을 기준으로 결합을 한다.

```{r}
df_var_names <- df_col_info %>%
  select( varname_eng , varname_kor)

summary_stats_4 <- summary_stats_3 %>%
  left_join( df_var_names,
    by = "varname_eng")

head(summary_stats_4, 20) %>%
  flextable() %>%
  autofit()
```


이제 한글 항목 이름(`varname_kor`)의 위치를 변경하고 영문 항목 이름(`varname_eng`)를 제거하면 연도별, 성별로 각 측정항목에 대한 기초통계를 나타내는 데이터 프레임을 만들 수 있다.

```{r}
summary_stats_5 <- summary_stats_4 %>%
  select( -varname_eng) %>%
  relocate( varname_kor, .before = stat) 

head(summary_stats_5, 20) %>%
  flextable() %>%
  autofit() 
```

위와 같이 컬럼에 포함된 자료의 내용을 바꾸는 작업은 함수 `case_match` 를 사용할 수도 있다. 예를 들어 위의 요약 통계량을 포함한  데이터프레임에서 통계량의 이름에 대한 컬럼(`stat`)에서 영문 통계량 이름을 다음과 같은 코드로 한글로 바꿀수 있다.

```{r}
final_summary_stats <- summary_stats_5 %>%
  mutate( stat = case_match( stat, 
        "mean" ~ "평균",
        "sd" ~ "표준편차",
        "min" ~ "최소값",
        "max" ~ "최대값")) 
  
head(final_summary_stats, 20) %>%
  flextable() %>%
  autofit() 
```

이제 최종적으로 각 컬럼의 이름을 한글로 바꾸면 다음과 같은 연도별, 성별로 각 측정항목에 대한 기초통계를 나타내는 데이터 프레임을 만들 수 있다.

```{r}
final_summary_stats <- final_summary_stats %>%
  rename( 년도 = TEST_YEAR,
          성별 = TEST_SEX,
          측정항목 = varname_kor,
          통계량 = stat,
          값 = value)

head(final_summary_stats, 20) %>%
  flextable() %>%
  autofit() 
```

만약 요약 통계결과를 성별, 년도에 따라서 다시 정렬하고 각 항목의 평균으로만 구성하고 싶다면 `arrange` 함수를 사용한다.

```{r}
final_summary_mean <- final_summary_stats %>%
  filter( 통계량 == "평균") %>%
  arrange( 성별, 측정항목, 년도, 통계량) %>%
  relocate( 성별, .before = 년도) %>%
  relocate( 측정항목, .before = 년도 ) 

head(final_summary_mean, 20) %>%
  flextable() %>%
  autofit()
```


## 시각화 분석 

### 두 변수의 관계 

이번 분석에서는 상대악력과 윗뭄말아올리기(`ITEM_F009`)와 관계를 시각적으로 분석해 보자.

먼저 상대악력(`rel_grip`)은 다음과 같이 좌우 악력의 최대값을 체중으로 나눈 값(%)으로 정의한다. 다음과 같이 분석을 위한 데이터프레임을 준비하자. 두 변수의 관계를 보기 위해서 함수 `na.omit` 을 적용해서 결측이 있는 자료는 제외한다.  


```{r}
df_grip <- df_data %>%
  mutate( grip_rel = pmax(ITEM_F007, ITEM_F008, na.rm = TRUE) / ITEM_F002 * 100 ) %>%
  rename(curl_up = ITEM_F009) %>%
  select( TEST_YEAR, TEST_SEX, TEST_AGE, curl_up, grip_rel) %>%
  na.omit()

head(df_grip, 20) %>%
  flextable() %>%
  autofit()
```


이제 상대악력과  윗몸말아올리기의 관계를 `ggplot` 함수를 이용하여 산점도로 나타내 보자.

```{r}
ggplot( df_grip, aes(x = grip_rel, y = curl_up)) +
  geom_point( alpha = 0.5, color = "blue") +
  labs( title = "상대악력과 윗몸말아올리기의 관계",
        x = "상대악력(%)",
        y = "윗몸말아올리기(회)") 
```   

두 변수의 관계는 성별로 다를 수 있으므로 남자와 여자의 자료를 색깔로 구별하여 산점도를 그려보자.

```{r}
ggplot( df_grip, aes(x = grip_rel, y = curl_up, color = TEST_SEX)) +
  geom_point( alpha = 0.7) +
  labs( title = "상대악력과 윗몸말아올리기의 관계 - 남녀별",
        x = "상대악력(%)",
        y = "윗몸말아올리기(회)",
        color = "성별") 
```

남녀벌로 다른 그림으로 분리하여 다음과 같이 두 개의 산점도로 나타낼 수 있다.

```{r}
ggplot( df_grip, aes(x = grip_rel, y = curl_up)) +
  geom_point( alpha = 0.7, color = "blue") +
  labs( title = "상대악력과 윗몸말아올리기의 관계 - 남녀별",
        x = "상대악력(%)",
        y = "윗몸말아올리기(회)") +
  facet_wrap( ~ TEST_SEX)
```
### 분포의 비교 

다음으로 연도별로 BMI(`ITEM_F018`) 분포를 비교해 보자. 이를 위해 `ggplot` 함수를 이용하여 각 연도마다 상자그림으로 분포를 나타낼 수 있다. 먼저 청소년 남자들의 분포를 비교해 보자.

```{r}
df_bmi_1 <- df_data %>%
  filter( TEST_SEX == "남성" &  AGE_GBN == "청소년") %>%
  select( TEST_YEAR, ITEM_F018) %>%
  rename( bmi = ITEM_F018, year = TEST_YEAR)

ggplot( df_bmi_1, aes(x = year, y = bmi )) +
  geom_boxplot(outlier.alpha = 0.7) +
  labs( title = "청소년 남자의 연도별 BMI 분포 비교",
        x = "연도",
        y = "BMI")
```


여자 청소년도 유사한 방법으로 년도별 BMI 의 분포를 비교해 보자.

```{r}
df_bmi_2 <- df_data %>%
  filter( TEST_SEX == "여성" &  AGE_GBN == "청소년") %>%
  select( TEST_YEAR, ITEM_F018) %>%
  rename( bmi = ITEM_F018, year = TEST_YEAR)

ggplot( df_bmi_2, aes(x = year, y = bmi )) +
  geom_boxplot(outlier.alpha = 0.7) +
  labs( title = "청소년 여자의 연도별 BMI 분포 비교",
        x = "연도",
        y = "BMI")
```

이제 남녀 별로 성인의 연도별 BMI 분포를 하나의 그림으로 비교해 보자. 이를 위해 `TEST_SEX` 변수를 `fill` 미적 요소로 지정하여 남녀를 색깔로 구별하여 상자그림을 그릴 수 있다.

```{r}
df_bmi_3 <- df_data %>%
  filter( AGE_GBN == "성인") %>%
  select( TEST_YEAR, TEST_SEX, ITEM_F018) %>%
  rename( bmi = ITEM_F018, year = TEST_YEAR, sex = TEST_SEX)
          
ggplot( df_bmi_3,
        aes(x = year, y = bmi, fill = sex)) +
  geom_boxplot(outlier.alpha = 0.7, position = position_dodge(0.8)) +
  labs( title = "성인 남녀의 연도별 BMI 분포 비교",
        x = "연도",
        y = "BMI",
        fill = "성별")
```
## 리포트 작성 예제 

이 절에서는 체력 측정 자료와 등급 기준 자료를 결합하여 청소년에 대하여 근지구력을 측정하는  윗몸말아올리기(`ITEM_F009`)와 반복점프(`ITEM_F010`)의 등급을 산정하여 분포를 구하고 
보고서에 사용할 수 있는 표외 그림를 만드는  절차를 설명한다. 

::: {.callout-caution}

국민체력100 청소년 근지구력에 대한  측정 항목은 윗몸말아올리기와 반복점프, 둘 중에 하나만 선택하여 측정한다. 따라서 한 사람에 대하여 두 변수 중 하나의 값은 결측값이다. 

:::

### 데이터 준비 

먼저 체력 측정 자료에서 청소년 자료만을 추출하여 새로운 데이터프레임 `df_youth` 를 만들자. 윗몸말아올리기와 반복점프가 모두 결측값인 경우는 자료에서 제외한다.

```{r}
df_report_wide <- df_data %>%
  filter( AGE_GBN == "청소년") %>%
  select( MEMB_SEQ, TEST_YEAR, TEST_SEX, TEST_AGE, ITEM_F009, ITEM_F010) %>%
  filter( !(is.na(ITEM_F009) & is.na(ITEM_F010)) )

head(df_report_wide, 20) %>%
  flextable() %>%
  autofit()
```

다음으로 등급 기준 자료 `df_class_level` 와 결합하려면 앞에서 만든 데이터프레임 `df_report_wide` 를 긴 형식위 자료로 만들어여 한다.

두 측정항목 중 하나만 선택하므로 측정값이 결측이면 자료에서 제외한다. 

```{r}
df_report_long <- df_report_wide %>%
  pivot_longer(
    cols = starts_with("ITEM"),
    names_to = "varname_eng",
    values_to = "value"
  ) %>%
  filter( !is.na(value))

head(df_report_long, 20) %>%
  flextable() %>%
  autofit()
```

다음으로 등급 기준 자료 `df_class_level` 를  결합에 사용하기 위하여 다음과 같이 재코딩하여 변수 형식을 변환 한다.

```{r}
df_class_level_ext <- df_class_level %>%
  rename(TEST_SEX = sex, TEST_AGE = age) %>%
  mutate( TEST_SEX = case_when(
      TEST_SEX == 1 ~ "남성",
      TEST_SEX == 2 ~ "여성")) %>%
  mutate(TEST_SEX = factor(TEST_SEX, levels = c("남성", "여성"))) %>%
  select(TEST_SEX, TEST_AGE, varname_eng,Q30, Q50, Q70)

head(df_class_level_ext, 20) %>%
  flextable() %>%
  autofit()
```


### 자료의 결합



이제 측정자료를 포함한 데이터프레임 `df_report_long` 을 기준으로 등급 기준이 포함된 데이터프레임 `df_class_level_ext` 을 성별, 연령별, 측정항목별로 결합하자.

```{r}
df_report_merged <- df_report_long %>%
  left_join( df_class_level_ext,
    by = c("TEST_SEX", "TEST_AGE", "varname_eng"))

head(df_report_merged, 20) %>%
  flextable() %>%
  autofit()
```

### 등급의 산정

이제 해당 측정항목이 30% 백분수(`Q30`) 미만이면 4등급, 30%-50%(`Q30`-`Q50`) 이면 3등급, 50%-70%(`Q50`-`Q70`) 이면  2등급, 70% 이상(`Q75`)이면 1등급으로 등급 변수 `class` 를 만들어 보자.

```{r}
df_report_class <- df_report_merged %>%
  mutate( class = case_when( value < Q30 ~ "4등급",
                             value >= Q30 & value < Q50 ~ "3등급",
                             value >= Q50 & value < Q70 ~ "2등급",
                             value >= Q70 ~ "1등급")) %>%
  mutate( class = factor(class, levels = c("1등급", "2등급", "3등급", "4등급"))) %>%
  select( MEMB_SEQ, TEST_YEAR, TEST_SEX, TEST_AGE, class)

head(df_report_class, 20) %>%
  flextable() %>%
  autofit()
```

### 등급 분포 

이제 연도별로 근지구력에 대한 등급의 분포를 구해보자. 아래 코드에서 함수 `count` 는 주어진 두 개의 변수 `TEST_YEAR` 와 `class` 의 조합별로 해당하는 사람의 개수를 `freq` 으로 저장하는 데이터프레임을 만들어 준다. 

```{r}
table_class_1 <- df_report_class %>%
  count(TEST_YEAR, class, name = "freq")

table_class_1 %>%
  flextable() %>%
  autofit()
```

다음으로 자료에 연도별로각 등급의 비율을 추가해 보자. 이를 위해 `group_by` 와 `mutate` 함수를 이용하여 연도별로 각 등급의 개수를 전체 인원수로 나누어 비율을 계산한다. 

```{r}
table_class_2 <- table_class_1 %>%
  group_by(TEST_YEAR) %>%
  mutate( percent = freq / sum(freq) * 100 ) %>%
  ungroup()

table_class_2 %>%
  flextable() %>%
  autofit()
```

마지막으로 보기 쉽도록 컬럼명을 한글로 바꾸어 보자. 또한 비율은 소수점 2자리까지 표현하자.

```{r}
table_class_2 <- table_class_2 %>%
  mutate( percent = round(percent, 2)) %>%
  rename( 년도 = TEST_YEAR, 등급 = class, 도수 = freq, 비율 = percent)

table_class_2 %>%
  flextable() %>%
  autofit()
```

### 분포표 작성 


이제 위에서 구한 등급의 분포를 등급이 변수명이 되는 넓은 형식의 자료로 만들어 보자. 또한 각 년도에 해당하는 총 인원도 계산에서 표에 포함한다.



```{r}
table_class_3 <- table_class_2 %>%
  pivot_wider(
    names_from = 등급,
    values_from = c(도수, 비율),
    names_glue = "{.value}_{등급}"
  ) %>%
  mutate(총인원 = rowSums(across(contains("도수")), na.rm = TRUE)) %>%
  relocate( 총인원, .after = 년도)

table_class_3 %>%
  flextable() %>%
  autofit()
```

::: {.callout-note}

#### `flextable` 의 `separate_header` 

`flextable` 패키지의 `separate_header` 함수는 언더바(`_`)로 연결된 컬럼명을 분리하여 계층적 컬럼명을 만들 수 있는 기능이 있다. 

```{r}
table_class_3 %>%
  flextable() %>%
  separate_header() %>% 
  autofit()
```

:::


### 분포 그림 작성

이제 연도별로 각 등급의 비율을 비교할 수 있는 누적 막대그래프를 그려보자. 이를 위해 `ggplot` 함수를 이용하여 막대그래프를 그린다. 이 경우 긴 형식의 자료를 이용해야 한다.



```{r}
ggplot(table_class_2, aes(x = 년도, y = 비율, fill = 등급)) +
  geom_bar(stat = "identity") +
  geom_text(
    aes(label = sprintf("%.1f%%", 비율)),
    position = position_stack(vjust = 0.5),
    size = 3
  ) +
  labs(title = "연도별 청소년 근지구력 등급 분포",
    x = "연도", y = "비율(%)", fill = "등급")
```

### `quarto` 의 리포트 작성

이제 위에서 작성한 표와 그림을 `quarto` 리포트에 포함하여 최종 보고서를 HTML 또는 MS WORD 형식으로 출력할 수 있다. `quarto` 문서(확장자가 `qmd` 인 화일)에서 가장 처음에 다음과 같은 YML 해더를 포함시키면 HTML 또는 MS WORD 형식으로 결과를 저장한다.

아래 YML 형식의 명령문에서 `reference-doc` 는 MS WORD 형식으로 결과를 저장할 때 style reference 를 사용할 화일 이름이다([다음 사이트 참조](https://quarto.org/docs/output-formats/ms-word-templates.html#:~:text=Word%20Templates-,Using%20Templates,Applying%20Custom%20Styles)).
```
---
title: "국민체력 100 자료를 이용한 데이터 분석 예제"
author: "서울시립대학교 빅데이터 혁신융합대학 사업단"
date: "today"

format:
  html:
    toc: true
    embed-resources: true
  docx: 
    toc: true
    toc-depth: 2 
    number-sections: true
    reference-doc: custom-reference-doc-landscape.docx
---
```