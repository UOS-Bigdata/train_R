---
title: "국민체력 100 자료를 이용한 데이터 분석 예제"
author: "서울시립대학교 빅데이터 혁신융합대학 사업단"
date: "today"

format:
  html:
    toc: true
    embed-resources: true
    fig-cap-location: top
  docx: 
    toc: true
    toc-depth: 2 
    number-sections: true
    reference-doc: custom-reference-doc-landscape.docx
---

## 필요한 패키지

다음은 본 예제를 실행하는 데 필요한 R 패키지들이다. 패키지가 설치되어 있지 않은 경우에는 먼저 설치한 후 로드한다.

```{r}
#| warning: false
#| message: false

library(tidyverse) # 데이터 처리 및 시각화 패키지
library(lubridate) # 날짜 처리 패키지
library(stringr) # 문자열 처리 패키지
library(readxl) # 엑셀 파일 읽기 위한 패키지
#library(openxlsx) # 엑셀 파일 읽기 위한 패키지
library(flextable) # 표 작성 패키지
library(here) # 파일 경로 설정을 위한 패키지

# ggplot 으로 그림을 그릴 때 한글이 깨지지 않게 폰트 Nanum Pen Script를 선택
library(showtext)
font_add_google("Nanum Pen Script", "gl")
showtext_auto()
```


## 개요 

국민체력 100 사업은 국민의 기초체력을 증진시키기 위하여 국민체력 측정 및 평가, 운동처방, 체력증진 프로그램 운영 등을 실시하는 사업이다.
이 사업을 통해 수집된 자료는 국민의 체력 수준을 파악하고, 체력 증진을 위한 다양한 프로그램을 개발하는 데 활용된다. 
본 예제에서는 국민체력 100 자료를 이용하여 데이터에 대한 전처리 및 기초 분석과 시각화를 수행하는 방법을 다룬다.

마지막으로 체력 측정 자료와 등급 기준 자료를 결합하여 보고서에 사용할 수 있는 요약표와 그래프를 만드는 실습을 수행한다. 


## 데이터 불러오기 

### 데이터 파일 개요 

이 예제에서는 다음과 같은 3 개의 엑셀 파일에 저장된 데이터를 사용할 것이다.

- `sample_data_sports100.xlsx`: 
  + 국민체력 100 사업에서 측정 데이터로 인구통계적 변수와 체력 측정항목으로 구성된 자료
  + 13세-18세의 청소년 자료로서 1000명의 표본자료
  
- `columns_info.xlsx`: 
  + 국민체력 100 측정 데이터의 각 변수에 대한 설명이 포함된 자료
  + 변수명, 변수 설명, 단위 등의 정보가 담겨 있다.
  + 각 측정 항목에 대한 측정 가능한 범위에 대한 최소값과 최대값이 포함되어 있다. 

- `class_level.xlsx`: 
  + 국민체력 100 측정 데이터의 각 체력 측정항목에 대한 등급 기준이 포함된 가상의 자료
  + 측정항목에 대하여 연령대별, 성별로 30, 50, 70 백분위수가 저장되어 있다.
  + 편의상 해당 측정항목이 30% 백분수 미만이면 4등급, 30%-50% 이면 3등급, 50%-70% 이면 2등급, 70% 이상이면 1등급 

::: {.callout-note}

### 분위수란?

분위수(quantile) 는 자료를 크기 순으로 정렬했을 때, 전체를 일정한 비율로 나누는 기준값을 말한다. 예를 들어 중앙값(50% 분위수) 은 자료의 절반이 그 값 이하가 되도록 하는 지점이며, 사분위수(25%, 50%, 75%) 는 자료를 네 구간으로 나누는 기준값이다. 분위수를 활용하면 평균처럼 일부 극단값의 영향을 크게 받지 않으면서도, 자료의 분포와 개인의 상대적 위치를 직관적으로 파악할 수 있다.

:::

다음은 위에서 설명한 3개의 엑셀파일의 일부를 나타낸 그림이다.

::: {#fig-data1}

![`sample_data_sports100.xlsx`](./images/data_1.png){width=80%}

국민체력 100 사업의 측정 데이터
:::


::: {#fig-data2}

![`column_info.xlsx`](./images/data_2.png){width=80%}

국민체력 100 측정 데이터의 설명 자료
:::


::: {.callout-note}

### 변수 정보 자료 

많은 종류의 자료를 관리하는 경우 각 항목의 이름을 의미가 있는 영문명이나 한글명으로 관리하는 것은 복잡한 작업이다. 우리가 위에서 본 국민체력100에 대한 자료에서 관측값을 저장하는 `sample_data_sport100.xlsx` 에서는 변수명을 `ITEM_XXX` 와 같이 번호가 붙은 컬럼명을 사용한다.

더 나아가 별도의 자료  `columns_info.xlsx` 는 변수명 `ITEM_XXX` 에 대한 한글이름, 체력 측정에 대한 부문, 단위, 정상값 범위 등 측정항목에 대한 정보(즉 메타 정보; Meta Infomation)를 포함한다.

이렇게 측정값을 저장하는 데이터와 측정항목의 정보를 저장하는 데이터를 따로 관리하고 서료 결합할 수 있게 하면 자료의 확정성이 커지고 관리가 편리하다.

:::


::: {#fig-data3}

![`class_level.xlsx`](./images/data_3.png){width=80%}


국민체력 100 측정 데이터의 등급 기준 자료 
:::

### 데이터 불러오기 

이제 `R`을 이용하여 위에서 설명한 3 개의 엑셀 파일을 불러오자. 이를 위해 `readxl` 패키지의 함수 `read_xlsx`를 사용한다.
함수 `read_xlsx` 에서 사용된 `col_names = TRUE` 선택문은 엑셀파일의 첫 번째 행의 내용을 컬럼의 이름으로 하기위한 선택문이다. 

```{r}
# 데이터 불러오기
df_data <- read_xlsx(here("data", "sample_data_sports100.xlsx"), col_names = TRUE)
df_col_info <- read_xlsx(here("data", "column_info.xlsx"), col_names = TRUE)
df_class_level <- read_xlsx(here("data", "class_level.xlsx"), col_names = TRUE)
```

::: {.callout-note}

### `here()` 함수 설명

`here()` 함수는 R 프로젝트에서 파일 경로를 쉽게 관리할 수 있도록 도와주는 함수이다. 이 함수는 프로젝트의 루트 디렉토리를 기준으로 상대 경로를 생성하여, 파일을 불러오거나 저장할 때 편리하게 사용할 수 있다.

예를 들어, `here("data", "sample_data_sports100.xlsx")`는 현재 R 프로젝트의 루트 디렉토리에서 `data` 폴더 안에 있는 `sample_data_sports100.xlsx` 파일의 경로를 생성한다. 이를 통해 코드가 다른 컴퓨터나 환경에서 실행될 때도 파일 경로 문제를 최소화할 수 있다.

:::

이제 불러온 자료의 일부와 구조를 살펴보면서 자료가 정확하게 데이터프레임으로 만들어졌는지 살펴보자.

```{r}
head(df_data)
head(df_col_info)
head(df_class_level)
```


## 데이터 전처리 

먼저 함수 `glimpse` 을 이용하여 측정 자료 `df_data` 의 각 컬럼들이 어떠한 형식으로 입력되어 있는지 살펴보자 

```{r}
glimpse(df_data)
```

먼저 연령을 나타내는 컬럼 `TEST_AGE` 가 실수형(double)으로 입력되어 있으므로 편의상 정수형(integer) 로 변환하자.

```{r}
df_data <- df_data %>%
  mutate( TEST_AGE = as.integer(TEST_AGE))
```


### 날짜 변수의 생성

먼저 데이터프레임 `df_data` 에서  `TEST_MD` 컬럼은 측정 날짜를 나타내는 데이터이지만 엑셀 파일에서 자료 입력시 문자형 변수로 입력이 된다. 일반적으로 날짜를 나타내는 자료는 날짜형 변수로 형식을 바꾸는 것이 다루기 편하다.

```{r}
glimpse(df_data$TEST_MD)

df_data <- df_data %>%
  mutate(
    TEST_MD = ymd(TEST_MD)
  )

glimpse(df_data$TEST_MD)
```


다음으로 측정 년도를 나타내는 새로운 변수 `TEST_YEAR` 를 함수 `year` 를 이용하여 생성하고, 다시 범주형으로 변환하여 컬럼의 위치를 `TEST_MD` 뒤에 있도록 하자. 일반적으로 년도를 나타내는 변수는 정수형이지만 범주형으로 사용하는 것이 편리하다. 

```{r}
df_data <- df_data %>%
  mutate(TEST_YEAR = factor(year(TEST_MD))) %>%
  relocate(TEST_YEAR, .after = TEST_MD)
```


### 범주형 변수의 변환 

다음으로 성별을 나타내는 `TEST_SEX` 변수의 값이 `M`이면  `남성`, `F`이면 `여성` 으로 문자형으로 바꾸고 범주형 변수(factor)로 변환하자.

또한 생애 주기를 나타내는 변수 `AGE_GBN` 범주형 변수로 변환하자. 이 경우 `levels` 선택문을 사용하여 항목의 순서를 `청소년`, `성인`, `어르신` 순서로 지정할 수 있다. 

```{r}
df_data <- df_data %>%
  mutate(TEST_SEX = case_when(
      TEST_SEX == "M" ~ "남성", 
      TEST_SEX == "F" ~ "여성")) %>% 
  mutate( TEST_SEX = factor(TEST_SEX, levels = c("남성", "여성"))) %>%
  mutate( AGE_GBN = factor(AGE_GBN, levels = c("청소년", "성인",   "어르신")))

glimpse(df_data)
```

::: {.callout-note}

### `case_when` 함수 설명

`case_when()`은 여러 조건에 따라 값을 나누어 지정할 때 사용하는 함수이다. 조건문을 여러 번 쓰는 대신, 조건을 위에서부터 순서대로 검사하여 **처음으로 TRUE가 되는 값**을 반환한다.

:::


## 기술 통계 분석

###  범주형 자료의 분포 

먼저 2000명의 사랍들을 연도별, 성별, 생애주기별 도수 분포표를 만들어 보자. 가장 기본적인 범주형 자료의 분포를 만들 수 있는 함수는 `table` 함수이다.

```{r}
table(df_data$TEST_YEAR)
table(df_data$TEST_SEX)
table(df_data$AGE_GBN)
```

다음과 같이 함수 `table` 을 이용하여 2개의 변수에 대한 교차표(cross table) 도 만들 수 있다.

```{r}
table( df_data$TEST_SEX, df_data$TEST_YEAR)
```

`table` 함수로 만든 교차표를 데이터프레임으로 바꾸면 다음과 같은 형식의 자료가 생성된다.

```{r}
as.data.frame( table( df_data$TEST_SEX, df_data$TEST_YEAR))
```


`table` 함수는 간단하게 범주형 변수의 분포를 파악하는 데 유용하지만, `dplyr` 패키지를 이용하면 보다 유연하게 다양한 형태의 요약표를 만들 수 있다. 이제 `dplyr` 패키지의 `group_by` 와 `summarise` 함수를 이용하여 범주형 변수의 분포를 요약한 표를 만들어 보자. 교차표에 연도별 남녀의 비율을 추가하는 코드도 추가해보자. 

```{r}
cross_tbl_01 <- df_data %>%
  group_by(TEST_YEAR, TEST_SEX) %>%
  summarise(n = n(), .groups = "drop_last") %>%
  mutate(percent = n / sum(n) * 100 ) 

cross_tbl_01
```

::: {.callout-note}

#### `summarise()` 함수의 `.groups` 인자 설명

`summarise()` 함수의 `.groups` 인자는 요약된 결과 데이터프레임에서 그룹화된 변수를 어떻게 처리할지를 지정하는 역할을 한다. 이 인자는 다음과 같은 옵션들을 가질 수 있다:

- `"drop"`: 모든 그룹화를 제거하고 결과를 단일 데이터프레임으로 반환한다.
- `"drop_last"`: 마지막 그룹화 변수만 제거하고 나머지 그룹화 변수는 유지한다.
- `"keep"`: 모든 그룹화 변수를 유지한다.
- `"rowwise"`: 결과를 행 단위로 그룹화한다.
:::

다음과 같이 `.groups = "drop_last"` 를 이용한 결과를 위의 결과와 비교해보자. 위에서 처럼 `.groups = "drop_last"` 를 이용하면  `summarise` 함수에서  마지막 그룹화 변수인 `TEST_SEX` 만 제거되고, `TEST_YEAR` 는 여전히 그룹화된 상태로 유지된다. 따라서 결과 데이터프레임은 `TEST_YEAR` 별로 요약된 형태로 나타난다. 반면, `.groups = "drop"`을 사용하면  그룹화 정보가 모두 제거되어 비율은 전체 자료 기준으로 계산된다.

```{r}
cross_tbl_02 <- df_data %>%
  group_by(TEST_YEAR, TEST_SEX) %>%
  summarise( n = n(), .groups = "drop") %>%
  mutate( percent = n / sum(n) * 100 ) 

cross_tbl_02
```

### 연속형 자료의 요약

다음으로 연속형 변수들의 요약 통계량을 계산해 보자. 이를 위해 `dplyr` 패키지의 `summarise` 함수를 이용하여 각 변수에 대한 평균, 표준편차, 최소값, 최대값 등을 계산할 수 있다. 예를 들어, 연도별, 성별로 신장(`ITEM_F001`)에 대한 요약 통계량을 계산하는 코드는 다음과 같다.


```{r}
summary_stats_1 <- df_data %>%
   group_by(TEST_YEAR, TEST_SEX) %>%
  summarise(
    height_mean = mean(ITEM_F001, na.rm = TRUE),
    height_sd = sd(ITEM_F001, na.rm = TRUE), 
     .groups = "keep")

summary_stats_1
```

더 나아가 여러 개의 변수들에 대하여 요약 통계량을 한꺼번에 계산하려면 `across` 함수를 사용할 수 있다. 예를 들어, 신장(`ITEM_F001`), 몸무게(`ITEM_F002`), 체지방률(`ITEM_F003`)에 대한 요약 통계량을 한꺼번에 계산하는 코드는 다음과 같다.

```{r}
summary_stats_2 <- df_data %>%
  group_by(TEST_YEAR, TEST_SEX) %>%
  summarise(
    across(c(ITEM_F001, ITEM_F002, ITEM_F003), 
      list(mean = ~ mean(.x, na.rm = TRUE),
           sd = ~ sd(.x, na.rm = TRUE),
           min = ~ min(.x, na.rm = TRUE),
           max = ~ max(.x, na.rm = TRUE)
      ),
    .names = "{.col}-{.fn}"
    ),
    .groups = "keep"
  )

summary_stats_2
```


::: {.callout-note}

#### `flextable` 의 이용 

데이터프레임을 출력하는 경우 표 형식(tbale format)으로 보기 좋게 출력하려면 `flextable` 함수를 사용하면 된다.  패키지 `flextable` 포함된 `flextable` 과 `autofit` 두 함수를 사용하면 보기 편한 표 형식으로 데이터를 출력할 수 있다. 

:::

이제 위에서 구한 데이터프레임 `summary_stats_2` 의 일부를 `flextable` 함수를 이용하여 출력해보자.

```{r}
head(summary_stats_2, 20) %>%
  flextable() %>%
  autofit()
```




### 자료의 형태 변환

::: {.callout-note}

#### 넓은 형식와 긴 형식의 자료


- **넓은 형식의 자료(wide format data)**
  + 하나의 개체에 해당하는 값들이 한 행으로 구성
  + 보고서 및 요약표 작성에 적합

::: {#fig-wide}

![](./images/wide_format.png){width=50%}

넓은 형식의 자료 
:::

- **긴 형식의 자료(long format data)**
  + 하나의 개체에 해당하는 값들이 여러 개의 행으로 구성
  + 통계 분석 및 시계열 분석에 적합

::: {#fig-long}

![](./images/long_format.png){width=30%}

긴 형식의 자료 
:::

두 형식은 두 함수 `pivot_wider` 와 `pivot_longer` 로 서로 변환할 수 있다.

:::

위의 결과는 각 변수의 통계량(평균, 표준편차, 최소값, 최대값)이 컬럼 형태로 저장된 **넓은 형태의 자료(wide format data)**이다. 이제  통계량의 값을 하나의 컬럼에 저장하는 **긴 형태의 자료(long format data)** 로 바꾸어 보자. 이를 위해 `pivot_longer` 함수를 사용한다.

```{r}
summary_stats_3 <- summary_stats_2 %>%
  pivot_longer(
    cols = starts_with("ITEM"),
    names_sep = "-", 
    names_to = c("varname_eng", "stat"),
    values_to = "value"
  )

head(summary_stats_3, 20) %>%
  flextable() %>%
  autofit()
```

### 재코딩 및 변수 이름 바꾸기


다음으로 긴 형태의 자료(long format data)에서 `ITEM` 변수에 저장된 측정 항목의 변수명을 `df_col_info` 에 저장된 한글 측정 항목의 이름으로 바꾸어 작업을 다음과 같이 할 수 있다.

먼저 `df_col_info` 에서 영문 항목 이름(`varname_eng`) 과 한글 항목 이름(`varname_kor`) 를 선택하고 위에서 만든 `summary_stats_3` 에 있는 영문 항목 이름을 기준으로 결합을 한다.

```{r}
df_var_names <- df_col_info %>%
  select( varname_eng , varname_kor)

summary_stats_4 <- summary_stats_3 %>%
  left_join( df_var_names,
    by = "varname_eng")

head(summary_stats_4, 20) %>%
  flextable() %>%
  autofit()
```


이제 한글 항목 이름(`varname_kor`)의 위치를 변경하고 영문 항목 이름(`varname_eng`)를 제거하면 연도별, 성별로 각 측정항목에 대한 기초통계를 나타내는 데이터 프레임을 만들 수 있다.

```{r}
summary_stats_5 <- summary_stats_4 %>%
  select( -varname_eng) %>%
  relocate( varname_kor, .before = stat) 

head(summary_stats_5, 20) %>%
  flextable() %>%
  autofit() 
```

위와 같이 컬럼에 포함된 자료의 내용을 바꾸는 작업은 함수 `case_match` 를 사용할 수도 있다. 예를 들어 위의 요약 통계량을 포함한  데이터프레임에서 통계량의 이름에 대한 컬럼(`stat`)에서 영문 통계량 이름을 다음과 같은 코드로 한글로 바꿀수 있다.

```{r}
final_summary_stats <- summary_stats_5 %>%
  mutate( stat = case_match( stat, 
        "mean" ~ "평균",
        "sd" ~ "표준편차",
        "min" ~ "최소값",
        "max" ~ "최대값")) 
  
head(final_summary_stats, 20) %>%
  flextable() %>%
  autofit() 
```

이제 최종적으로 각 컬럼의 이름을 한글로 바꾸면 다음과 같은 연도별, 성별로 각 측정항목에 대한 기초통계를 나타내는 데이터 프레임을 만들 수 있다.

```{r}
final_summary_stats <- final_summary_stats %>%
  rename( 년도 = TEST_YEAR,
          성별 = TEST_SEX,
          측정항목 = varname_kor,
          통계량 = stat,
          값 = value)

head(final_summary_stats, 20) %>%
  flextable() %>%
  autofit() 
```

만약 요약 통계결과를 성별, 년도에 따라서 다시 정렬하고 각 항목의 평균으로만 구성하고 싶다면 `arrange` 함수를 사용한다.

```{r}
final_summary_mean <- final_summary_stats %>%
  filter( 통계량 == "평균") %>%
  arrange( 성별, 측정항목, 년도, 통계량) %>%
  relocate( 성별, .before = 년도) %>%
  relocate( 측정항목, .before = 년도 ) 

head(final_summary_mean, 20) %>%
  flextable() %>%
  autofit()
```


## 시각화 분석 

### 두 변수의 관계 

이번 분석에서는 상대악력과 윗뭄말아올리기(`ITEM_F009`)와 관계를 시각적으로 분석해 보자.

먼저 상대악력(`rel_grip`)은 다음과 같이 좌우 악력의 최대값을 체중으로 나눈 값(%)으로 정의한다. 다음과 같이 분석을 위한 데이터프레임을 준비하자. 두 변수의 관계를 보기 위해서 함수 `na.omit` 을 적용해서 결측이 있는 자료는 제외한다.  


```{r}
df_grip <- df_data %>%
  mutate( grip_rel = pmax(ITEM_F007, ITEM_F008, na.rm = TRUE) / ITEM_F002 * 100 ) %>%
  rename(curl_up = ITEM_F009) %>%
  select( TEST_YEAR, TEST_SEX, TEST_AGE, curl_up, grip_rel) %>%
  na.omit()

head(df_grip, 20) %>%
  flextable() %>%
  autofit()
```


이제 상대악력과  윗몸말아올리기의 관계를 `ggplot` 함수를 이용하여 산점도로 나타내 보자.

```{r}
ggplot( df_grip, aes(x = grip_rel, y = curl_up)) +
  geom_point( alpha = 0.5, color = "blue") +
  labs( title = "상대악력과 윗몸말아올리기의 관계",
        x = "상대악력(%)",
        y = "윗몸말아올리기(회)") 
```   

두 변수의 관계는 성별로 다를 수 있으므로 남자와 여자의 자료를 색깔로 구별하여 산점도를 그려보자.

```{r}
ggplot( df_grip, aes(x = grip_rel, y = curl_up, color = TEST_SEX)) +
  geom_point( alpha = 0.7) +
  labs( title = "상대악력과 윗몸말아올리기의 관계 - 남녀별",
        x = "상대악력(%)",
        y = "윗몸말아올리기(회)",
        color = "성별") 
```

남녀벌로 다른 그림으로 분리하여 다음과 같이 두 개의 산점도로 나타낼 수 있다.

```{r}
ggplot( df_grip, aes(x = grip_rel, y = curl_up)) +
  geom_point( alpha = 0.7, color = "blue") +
  labs( title = "상대악력과 윗몸말아올리기의 관계 - 남녀별",
        x = "상대악력(%)",
        y = "윗몸말아올리기(회)") +
  facet_wrap( ~ TEST_SEX)
```
### 분포의 비교 

다음으로 연도별로 BMI(`ITEM_F018`) 분포를 비교해 보자. 이를 위해 `ggplot` 함수를 이용하여 각 연도마다 상자그림으로 분포를 나타낼 수 있다. 먼저 청소년 남자들의 분포를 비교해 보자.

```{r}
df_bmi_1 <- df_data %>%
  filter( TEST_SEX == "남성" &  AGE_GBN == "청소년") %>%
  select( TEST_YEAR, ITEM_F018) %>%
  rename( bmi = ITEM_F018, year = TEST_YEAR)

ggplot( df_bmi_1, aes(x = year, y = bmi )) +
  geom_boxplot(outlier.alpha = 0.7) +
  labs( title = "청소년 남자의 연도별 BMI 분포 비교",
        x = "연도",
        y = "BMI")
```


여자 청소년도 유사한 방법으로 년도별 BMI 의 분포를 비교해 보자.

```{r}
df_bmi_2 <- df_data %>%
  filter( TEST_SEX == "여성" &  AGE_GBN == "청소년") %>%
  select( TEST_YEAR, ITEM_F018) %>%
  rename( bmi = ITEM_F018, year = TEST_YEAR)

ggplot( df_bmi_2, aes(x = year, y = bmi )) +
  geom_boxplot(outlier.alpha = 0.7) +
  labs( title = "청소년 여자의 연도별 BMI 분포 비교",
        x = "연도",
        y = "BMI")
```

이제 남녀 별로 성인의 연도별 BMI 분포를 하나의 그림으로 비교해 보자. 이를 위해 `TEST_SEX` 변수를 `fill` 미적 요소로 지정하여 남녀를 색깔로 구별하여 상자그림을 그릴 수 있다.

```{r}
df_bmi_3 <- df_data %>%
  filter( AGE_GBN == "성인") %>%
  select( TEST_YEAR, TEST_SEX, ITEM_F018) %>%
  rename( bmi = ITEM_F018, year = TEST_YEAR, sex = TEST_SEX)
          
ggplot( df_bmi_3,
        aes(x = year, y = bmi, fill = sex)) +
  geom_boxplot(outlier.alpha = 0.7, position = position_dodge(0.8)) +
  labs( title = "성인 남녀의 연도별 BMI 분포 비교",
        x = "연도",
        y = "BMI",
        fill = "성별")
```
## 리포트 작성 예제 

이 절에서는 체력 측정 자료와 등급 기준 자료를 결합하여 청소년에 대하여 근지구력을 측정하는  윗몸말아올리기(`ITEM_F009`)와 반복점프(`ITEM_F010`)의 등급을 산정하여 분포를 구하고 
보고서에 사용할 수 있는 표외 그림를 만드는  절차를 설명한다. 

::: {.callout-caution}

국민체력100 청소년 근지구력에 대한  측정 항목은 윗몸말아올리기와 반복점프, 둘 중에 하나만 선택하여 측정한다. 따라서 한 사람에 대하여 두 변수 중 하나의 값은 결측값이다. 

:::

### 데이터 준비 

먼저 체력 측정 자료에서 청소년 자료만을 추출하여 새로운 데이터프레임 `df_youth` 를 만들자. 윗몸말아올리기와 반복점프가 모두 결측값인 경우는 자료에서 제외한다.

```{r}
df_report_wide <- df_data %>%
  filter( AGE_GBN == "청소년") %>%
  select( MEMB_SEQ, TEST_YEAR, TEST_SEX, TEST_AGE, ITEM_F009, ITEM_F010) %>%
  filter( !(is.na(ITEM_F009) & is.na(ITEM_F010)) )

head(df_report_wide, 20) %>%
  flextable() %>%
  autofit()
```

다음으로 등급 기준 자료 `df_class_level` 와 결합하려면 앞에서 만든 데이터프레임 `df_report_wide` 를 긴 형식위 자료로 만들어여 한다.

두 측정항목 중 하나만 선택하므로 측정값이 결측이면 자료에서 제외한다. 

```{r}
df_report_long <- df_report_wide %>%
  pivot_longer(
    cols = starts_with("ITEM"),
    names_to = "varname_eng",
    values_to = "value"
  ) %>%
  filter( !is.na(value))

head(df_report_long, 20) %>%
  flextable() %>%
  autofit()
```

다음으로 등급 기준 자료 `df_class_level` 를  결합에 사용하기 위하여 다음과 같이 재코딩하여 변수 형식을 변환 한다.

```{r}
df_class_level_ext <- df_class_level %>%
  rename(TEST_SEX = sex, TEST_AGE = age) %>%
  mutate( TEST_SEX = case_when(
      TEST_SEX == 1 ~ "남성",
      TEST_SEX == 2 ~ "여성")) %>%
  mutate(TEST_SEX = factor(TEST_SEX, levels = c("남성", "여성"))) %>%
  select(TEST_SEX, TEST_AGE, varname_eng,Q30, Q50, Q70)

head(df_class_level_ext, 20) %>%
  flextable() %>%
  autofit()
```


### 자료의 결합



이제 측정자료를 포함한 데이터프레임 `df_report_long` 을 기준으로 등급 기준이 포함된 데이터프레임 `df_class_level_ext` 을 성별, 연령별, 측정항목별로 결합하자.

```{r}
df_report_merged <- df_report_long %>%
  left_join( df_class_level_ext,
    by = c("TEST_SEX", "TEST_AGE", "varname_eng"))

head(df_report_merged, 20) %>%
  flextable() %>%
  autofit()
```

### 등급의 산정

이제 해당 측정항목이 30% 백분수(`Q30`) 미만이면 4등급, 30%-50%(`Q30`-`Q50`) 이면 3등급, 50%-70%(`Q50`-`Q70`) 이면  2등급, 70% 이상(`Q75`)이면 1등급으로 등급 변수 `class` 를 만들어 보자.

```{r}
df_report_class <- df_report_merged %>%
  mutate( class = case_when( value < Q30 ~ "4등급",
                             value >= Q30 & value < Q50 ~ "3등급",
                             value >= Q50 & value < Q70 ~ "2등급",
                             value >= Q70 ~ "1등급")) %>%
  mutate( class = factor(class, levels = c("1등급", "2등급", "3등급", "4등급"))) %>%
  select( MEMB_SEQ, TEST_YEAR, TEST_SEX, TEST_AGE, class)

head(df_report_class, 20) %>%
  flextable() %>%
  autofit()
```

### 등급 분포 

이제 연도별로 근지구력에 대한 등급의 분포를 구해보자. 아래 코드에서 함수 `count` 는 주어진 두 개의 변수 `TEST_YEAR` 와 `class` 의 조합별로 해당하는 사람의 개수를 `freq` 으로 저장하는 데이터프레임을 만들어 준다. 

```{r}
table_class_1 <- df_report_class %>%
  count(TEST_YEAR, class, name = "freq")

table_class_1 %>%
  flextable() %>%
  autofit()
```

다음으로 자료에 연도별로각 등급의 비율을 추가해 보자. 이를 위해 `group_by` 와 `mutate` 함수를 이용하여 연도별로 각 등급의 개수를 전체 인원수로 나누어 비율을 계산한다. 

```{r}
table_class_2 <- table_class_1 %>%
  group_by(TEST_YEAR) %>%
  mutate( percent = freq / sum(freq) * 100 ) %>%
  ungroup()

table_class_2 %>%
  flextable() %>%
  autofit()
```

마지막으로 보기 쉽도록 컬럼명을 한글로 바꾸어 보자. 또한 비율은 소수점 2자리까지 표현하자.

```{r}
table_class_2 <- table_class_2 %>%
  mutate( percent = round(percent, 2)) %>%
  rename( 년도 = TEST_YEAR, 등급 = class, 도수 = freq, 비율 = percent)

table_class_2 %>%
  flextable() %>%
  autofit()
```

### 분포표 작성 


이제 위에서 구한 등급의 분포를 등급이 변수명이 되는 넓은 형식의 자료로 만들어 보자. 또한 각 년도에 해당하는 총 인원도 계산에서 표에 포함한다.



```{r}
table_class_3 <- table_class_2 %>%
  pivot_wider(
    names_from = 등급,
    values_from = c(도수, 비율),
    names_glue = "{.value}_{등급}"
  ) %>%
  mutate(총인원 = rowSums(across(contains("도수")), na.rm = TRUE)) %>%
  relocate( 총인원, .after = 년도)

table_class_3 %>%
  flextable() %>%
  autofit()
```

::: {.callout-note}

#### `flextable` 의 `separate_header` 

`flextable` 패키지의 `separate_header` 함수는 언더바(`_`)로 연결된 컬럼명을 분리하여 계층적 컬럼명을 만들 수 있는 기능이 있다. 

```{r}
table_class_3 %>%
  flextable() %>%
  separate_header() %>% 
  autofit()
```

:::


### 분포 그림 작성

이제 연도별로 각 등급의 비율을 비교할 수 있는 누적 막대그래프를 그려보자. 이를 위해 `ggplot` 함수를 이용하여 막대그래프를 그린다. 이 경우 긴 형식의 자료를 이용해야 한다.



```{r}
ggplot(table_class_2, aes(x = 년도, y = 비율, fill = 등급)) +
  geom_bar(stat = "identity") +
  geom_text(
    aes(label = sprintf("%.1f%%", 비율)),
    position = position_stack(vjust = 0.5),
    size = 3
  ) +
  labs(title = "연도별 청소년 근지구력 등급 분포",
    x = "연도", y = "비율(%)", fill = "등급")
```

### `quarto` 의 리포트 작성

이제 위에서 작성한 표와 그림을 `quarto` 리포트에 포함하여 최종 보고서를 HTML 또는 MS WORD 형식으로 출력할 수 있다. `quarto` 문서(확장자가 `qmd` 인 화일)에서 가장 처음에 다음과 같은 YML 해더를 포함시키면 HTML 또는 MS WORD 형식으로 결과를 저장한다.

아래 YML 형식의 명령문에서 `reference-doc` 는 MS WORD 형식으로 결과를 저장할 때 style reference 를 사용할 화일 이름이다([다음 사이트 참조](https://quarto.org/docs/output-formats/ms-word-templates.html#:~:text=Word%20Templates-,Using%20Templates,Applying%20Custom%20Styles)).
```
---
title: "국민체력 100 자료를 이용한 데이터 분석 예제"
author: "서울시립대학교 빅데이터 혁신융합대학 사업단"
date: "today"

format:
  html:
    toc: true
    embed-resources: true
  docx: 
    toc: true
    toc-depth: 2 
    number-sections: true
    reference-doc: custom-reference-doc-landscape.docx
---
```